---
title: 数据库设计学习笔记
categories: Database
tags:
  - DataBase
  - Mysql
image: 'http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/20190304_1.jpg'
abbrlink: 262e0be1
updated: 2019-03-05 00:16:51
date: 2019-03-04 21:19:30
---
Database Design, Mysql
<!-- more -->
## 数据库设计作用
1. 有效存储
2. 高效查询

## 设计步骤
### 需求分析
   存储哪些数据，数据的时效性(是否需要分库分表或采取定时清理或迁移操作)
   实体之间的关系，实体属性和主键
### 逻辑设计
   将需求分析转化为ER图
   **数据库设计范式**
   数据库设计标准，符合高标准范式的必定符合低标准的范式。
   有1NF, 2NF, 3NF, BCNF, 4NF, 5NF,一般符合BCNF就可以。
#### 操作异常和数据冗余
   插入异常： 一个实体随另一个实体存在，无法单独插入数据为插入异常。
   更新异常：修改某个实体实例属性时需要更新多行数据为修改异常。
   删除异常: 删除某条数据时导致另一条数据信息丢失为删除异常。
   数据冗余: 相同数据在多个地方存在或表中某列可以由其他列计算得到。 
#### 第一范式
   数据库中的所有字段都是单一属性，不可再分的，即它是由基本数据类型构成的。
   即数据库中的表都是二维表，没有一个字段是复合对象，可以再拆分成多个字段来表示含义的。

#### 第二范式

   是否存在非主属性对于码的部分依赖。

      1. K为属性或属性组，如果其他属性完全依赖于K,则K为码，可以有多个码。
      2. 任何一个码中的元素为主属性。
      3. 这里部分依赖即指非主属性可由码的部分属性确定下来。

   |学号|姓名|系名|系主任|课名|分数|
   |----|----|----|------|----|----|
   |001|吴涛涛|自动化|孙主任|高数|89|
   |001|吴涛涛|自动化|孙主任|英语|99|
   |002|王二|计算机|张主任|英语|79|

      1. 如果新建了一个系，还没有招收学生，就无法插入到这张表中，所以为插入异常。
      2. 如果我转到了计算机系，需要修改我所有的分数数据记录，为更新异常。
      3. 如果删除了一个系的所有学生分数记录，该系的信息无法查询到了，为删除异常。
      4. 学生的姓名，系名和系主任多次重复，数据冗余。

   以上面例子为例, 一个学生只有一个学号,一个姓名，一个系名,一个系主任，Ta可以有多门课，
   一门课只有一个分数，所以可以看出其复合主键为学号加课名。

   学号决定了姓名，写成学号->姓名 

   学号和课名决定了分数，而集学号或课名都无法单独决定分数，所以学号+课名是对分数
   的**完全依赖**(x->y,如果任意一个x的真子集z，z不能决定y,则y完全依赖于x)。
   (学号，课名)F -> 分数
   
   x p-> y, y依赖于x,但不完全依赖于x,即部分依赖
   (学号，课名)P -> 姓名

   找码过程：先看单个元素是否能确定其他字段，再两两组合看是否确定，三三组合直到所有字段为
   一个码,其中如果A是码，根据码的完全依赖标准，所有包含A的属性组都不是码了。
   通过分析可以得知，码只有一个(学号，课名)
   而部分依赖有
   > (学号，课名) p-> 姓名
   > (学号，课名) p-> 系名
   > (学号，课名) p-> 系主任

   这里只有分数是完全依赖于这个码的。3个部分依赖中都是依赖于学号，所以可以把学号和其他依赖
   于它的字段一起拆出去作为一张表。
   可以分为
   > 选课表 学号 课名 分数
   > 学生表 学号 姓名 系名 系主任

   这样满足了NF2, 但是插入一个无学生的新系或删除某个系里所有学生信息后，都无法获取该系信息的
   问题。问题在于学号->系名，而系名->系主任，存在传递依赖，不符合NF3.

#### 第三范式

  3NF在2NF的基础上，消除了非主属性对于码的传递函数依赖。

  上个例子可以改进为
   > 选课表 学号 课名 分数
   > 学生表 学号 姓名 系名 
   > 系表   系名 系主任

   这样插入一个无学生的新系或删除某个系里所有学生信息就都不会丢失系信息了。

#### BCNF范式
   数据库中存在主属性对于码的传递函数依赖与部分函数依赖。

```txt
   1. 某公司有若干个仓库；
   2. 每个仓库只能有一名管理员，一名管理员只能在一个仓库中工作；
   3. 一个仓库中可以存放多种物品，一种物品也可以存放在不同的仓库中。
   每种物品在每个仓库中都有对应的数量。

   已知函数依赖集：仓库名 → 管理员，管理员 → 仓库名，（仓库名，物品名）→ 数量
   码：（管理员，物品名），（仓库名，物品名）
   主属性：仓库名、管理员、物品名
   非主属性：数量
   ∵ 不存在非主属性对码的部分函数依赖和传递函数依赖。
   ∴ 此关系模式属于3NF。

   1. 先新增加一个仓库，但尚未存放任何物品，是否可以为该仓库指派管理员？
   ——不可以，因为物品名也是主属性，根据实体完整性的要求，主属性不能为空。
   2. 某仓库被清空后，需要删除所有与这个仓库相关的物品存放记录，会带来什么问题？
   ——仓库本身与管理员的信息也被随之删除了。
   3. 如果某仓库更换了管理员，会带来什么问题？
   ——这个仓库有几条物品存放记录，就要修改多少次管理员信息。

   从这里我们可以得出结论，在某些特殊情况下，即使关系模式符合 3NF 的要求，仍然存在着插入异常，
   修改异常与删除异常的问题，仍然不是 ”好“ 的设计。

   造成此问题的原因：存在着主属性对于码的部分函数依赖与传递函数依赖。
   （在此例中就是存在主属性【仓库名】对于码【（管理员，物品名）】的部分函数依赖。

   解决办法就是要在 3NF 的基础上消除主属性对于码的部分与传递函数依赖。
   > 仓库（仓库名，管理员）
   > 库存（仓库名，物品名，数量）

   这样，之前的插入异常，修改异常与删除异常的问题就被解决了。
```

<hr />
<img src="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/20190304_1.jpg" class="full-image" />
