---
title: 数据库设计学习笔记
categories: Database
tags:
  - DataBase
  - Mysql

abbrlink: 262e0be1
updated: 2019-03-06 23:11:19
date: 2019-03-04 21:19:30
---
Database Design, Mysql
<!-- more -->
## 数据库设计作用
1. 有效存储
2. 高效查询

## 设计步骤
### 需求分析
   存储哪些数据，数据的时效性(是否需要分库分表或采取定时清理或迁移操作)
   实体之间的关系，实体属性和主键
### 逻辑设计
   将需求分析转化为ER图
   **数据库设计范式**
   数据库设计标准，符合高标准范式的必定符合低标准的范式。
   有1NF, 2NF, 3NF, BCNF, 4NF, 5NF,一般符合BCNF就可以。
#### 操作异常和数据冗余
   插入异常： 一个实体随另一个实体存在，无法单独插入数据为插入异常。
   更新异常：修改某个实体实例属性时需要更新多行数据为修改异常。
   删除异常: 删除某条数据时导致另一条数据信息丢失为删除异常。
   数据冗余: 相同数据在多个地方存在或表中某列可以由其他列计算得到。 
#### 第一范式
   数据库中的所有字段都是单一属性，不可再分的，即它是由基本数据类型构成的。
   即数据库中的表都是二维表，没有一个字段是复合对象，可以再拆分成多个字段来表示含义的。

#### 第二范式

   是否存在非主属性对于码的部分函数依赖。
   (所有单关键字段的表都符合2NF)

      1. K为属性或属性组，如果其他属性完全依赖于K,则K为码，可以有多个码。
      2. 任何一个码中的元素为主属性。
      3. 这里部分依赖即指非主属性可由码的部分属性确定下来。

   |学号|姓名|系名|系主任|课名|分数|
   |----|----|----|------|----|----|
   |001|吴涛涛|自动化|孙主任|高数|89|
   |001|吴涛涛|自动化|孙主任|英语|99|
   |002|王二|计算机|张主任|英语|79|

      1. 如果新建了一个系，还没有招收学生，就无法插入到这张表中，所以为插入异常。
      2. 如果我转到了计算机系，需要修改我所有的分数数据记录，为更新异常。
      3. 如果删除了一个系的所有学生分数记录，该系的信息无法查询到了，为删除异常。
      4. 学生的姓名，系名和系主任多次重复，数据冗余。

   以上面例子为例, 一个学生只有一个学号,一个姓名，一个系名,一个系主任，Ta可以有多门课，
   一门课只有一个分数，所以可以看出其复合主键为学号加课名。

   学号决定了姓名，写成学号->姓名 

   学号和课名决定了分数，而集学号或课名都无法单独决定分数，所以学号+课名是对分数
   的**完全依赖**(x->y,如果任意一个x的真子集z，z不能决定y,则y完全依赖于x)。
   (学号，课名)F -> 分数
   
   x p-> y, y依赖于x,但不完全依赖于x,即部分依赖
   (学号，课名)P -> 姓名

   找码过程：先看单个元素是否能确定其他字段，再两两组合看是否确定，三三组合直到所有字段为
   一个码,其中如果A是码，根据码的完全依赖标准，所有包含A的属性组都不是码了。
   通过分析可以得知，码只有一个(学号，课名)
   而部分依赖有
   > (学号，课名) p-> 姓名
   > (学号，课名) p-> 系名
   > (学号，课名) p-> 系主任

   这里只有分数是完全依赖于这个码的。3个部分依赖中都是依赖于学号，所以可以把学号和其他依赖
   于它的字段一起拆出去作为一张表。
   可以分为
   > 选课表 学号 课名 分数
   > 学生表 学号 姓名 系名 系主任

   这样满足了NF2, 但是插入一个无学生的新系或删除某个系里所有学生信息后，都无法获取该系信息的
   问题。问题在于学号->系名，而系名->系主任，存在传递依赖，不符合NF3.

#### 第三范式

  3NF在2NF的基础上，消除了非主属性对于码的传递函数依赖。

  上个例子可以改进为
   > 选课表 学号 课名 分数
   > 学生表 学号 姓名 系名 
   > 系表   系名 系主任

   这样插入一个无学生的新系或删除某个系里所有学生信息就都不会丢失系信息了。

#### BCNF范式
   数据库中不存在主属性对于码的传递函数依赖部分函数依赖。

```txt
   1. 某公司有若干个仓库；
   2. 每个仓库只能有一名管理员，一名管理员只能在一个仓库中工作；
   3. 一个仓库中可以存放多种物品，一种物品也可以存放在不同的仓库中。
   每种物品在每个仓库中都有对应的数量。

   已知函数依赖集：仓库名 → 管理员，管理员 → 仓库名，（仓库名，物品名）→ 数量
   码：（管理员，物品名），（仓库名，物品名）
   主属性：仓库名、管理员、物品名
   非主属性：数量
   ∵ 不存在非主属性对码的部分函数依赖和传递函数依赖。
   ∴ 此关系模式属于3NF。

   1. 先新增加一个仓库，但尚未存放任何物品，是否可以为该仓库指派管理员？
   ——不可以，因为物品名也是主属性，根据实体完整性的要求，主属性不能为空。
   2. 某仓库被清空后，需要删除所有与这个仓库相关的物品存放记录，会带来什么问题？
   ——仓库本身与管理员的信息也被随之删除了。
   3. 如果某仓库更换了管理员，会带来什么问题？
   ——这个仓库有几条物品存放记录，就要修改多少次管理员信息。

   从这里我们可以得出结论，在某些特殊情况下，即使关系模式符合 3NF 的要求，仍然存在着插入异常，
   修改异常与删除异常的问题，仍然不是 ”好“ 的设计。

   造成此问题的原因：存在着主属性对于码的部分函数依赖与传递函数依赖。
   （在此例中就是存在主属性【仓库名】对于码【（管理员，物品名）】的部分函数依赖。

   解决办法就是要在 3NF 的基础上消除主属性对于码的部分与传递函数依赖。
   > 仓库（仓库名，管理员）
   > 库存（仓库名，物品名，数量）

   这样，之前的插入异常，修改异常与删除异常的问题就被解决了。
```

又在网上看到另一个类似的例子，但它说明了满足BCNF规范会产生的问题。
```txt
有这样一个配件管理表WPE(WNO,PNO,ENO,QNT),其中WNO表示仓库号，
PNO表示配件号，ENO表示职工号，QNT表示数量。

有以下约束要求：

（1）       一个仓库有多名职工；

（2）       一个职工仅在一个仓库工作；

（3）       每个仓库里一种型号的配件由专人负责，但一个人可以管理几种配件；

（4）       同一种型号的配件可以分放在几个仓库中。

分析表中的函数依赖关系，可以得到：

（1）       ENO->WNO;

（2）       （WNO，PNO）->QNT

（3）       （WNO，PNO）->ENO

（4）       （ENO，PNO）->QNT

可以看到，候选键有：（ENO,PNO）;(WNO,PNO)。所以，ENO,PNO,WNO均为主属性，QNT为非主属性。显然，非主属性是直接依赖于候选键的。所以此表满足第三范式。

而我们观察一下主属性：（WNO,PNO）->ENO;ENO->WNO。显然WNO对于候选键（WNO,PNO）存在传递依赖，
所以不符合BCNF.

解决这个问题的办法是分拆为两个表：

管理表EP（ENO，PNO，QNT）；
工作表EW（ENO，WNO）。

但这样做会导致函数依赖（WNO,PNO）->ENO丢失。

4． 应用

虽然，不满足BCNF，也会导致一些冗余和一致性的问题。
但是，将表分解成满足BCNF的表又可能丢失一些函数依赖。
所以，一般情况下不会强制要求关系表要满足BCNF。
```

#### 4NF
指在满足3NF的情况下，表中不能包含一个实体的2个或多个互相独立的多值因子。

如有一个telephone表(用户号customerId, 固定电话号phone,移动电话号cell),phone和cell相互独立，
主键是用户号，没有非主属性的传递依赖,符合3NF,也没有部分依赖，符合2NF。

如果一个用户有多个固定电话和移动电话，它就违反了4NF,因为如果用户取消了第一个固定电话和
第2个移动电话，怎么维护数据，这2行是否要合并等等。

可以设计一个新表newTelephone(customerId, number, phoneType)。

#### 5NF
4NF处理相互独立的多值情况，5NF处理相互依赖的多值情况。

如销售信息表Sales(salesperson, vendor, product)在某些情况下有冗余，可以分解为
> person_vendor表(salesperson, vendor)
> person_product表(salesperson, product)
> vendor_product表(vendor, product)

#### 范式总结

```txt
总结：

   总之，规范化的过程就是在数据库表设计时移除数据冗余的过程。
   随着规范化的进行，数据冗余越来越少，但数据库的效率也越来越低。
   这就要求你在数据库设计中，能结合实际应用的性能要求，规范到合适的范式。
   一般情况下，如何性能允许的话，都要求规范到第三范式的。
```

### 物理设计 
1. 选择数据库管理系统。
2. 数据库，表及字段的命名规范。
3. 根据DBMS系统选择合适的字段类型。 
4. 反范式化设计(如为了效率的提升，进行一些数据冗余处理)

#### mysql存储引擎
|存储引擎|事物|锁粒度|应用|忌用|
|--------|----|----|----|--|
|MylSAM|不支持|并发插入表级锁|select,Insert|频繁读写|
|MRG_MYISAM|不支持|并发插入表级锁|分段归档，数据仓库|全局查找过多|
|Innodb(5.5后)|支持|行级锁|事务处理|无|
|Archive|不支持|行级锁|日志记录，只支持insert,select|需要更新，删除,随机读取|
|Ndb cluster|支持|行级锁|高可用性|大部分应用|

#### 表及字段命名规范
1. 可读性原则(有些DBMS大小写敏感)
2. 表意性原则
3. 长名原则

#### 字段类型的选择原则 
**优先数字类型，其次日期类型，最后同类型下，选择存储空间小的类型。**

原因:
1. 数据进行比较时(查询，join及排序),字符比数字慢。
2. 数据库是按页处理的，列的长度越小，页数越少，IO开销越小，从而性能越高。

#### char和varchar
1. 如果数据长度基本一致，可以选择char.
2. 如果列最大数据长度小于50byte,可以考虑char.(如果很少用，为减少空间也可以用varchar)
3. 大于50byte的数据一般为varchar。
#### decimal和float
1. decimal用于存储精确数据，float用于存储非精确数据。
2. float存储空间开销小，非精确数据优先float.
#### 时间类型
1. int存储时间
存储消耗比datetime小，但使用时需要转换，而且因为有2^32的最大值限制，只能存到2038.1.19
2. 时间粒度 y,m,d 当不需要那么精确时可以选择年月日字段类型。
#### 选择主键
1. 区分业务主键和数据库主键(如果没有主键，innodb会生成6个字节的隐含主键)
2. 主键是否要顺序增长，
3. 主键字段类型占有空间少
#### 避免使用外键
1. 降低数据导入效率（导入时会检查是否满足外键约束）
2. 增加维护成本
3. 关联列上可以增加索引
#### 避免使用触发器
1. 降低数据导入效率
2. 可能会出现数据异常
3. 业务逻辑变的复杂
#### 不预留字段
1. 无法知道预留字段类型
2. 无法知道存储内容
3. 维护成本和新建字段成本相同
4. 严禁使用预留字段
#### 反范式化
用空间换时间
1. 减少表的关联个数
2. 增加读取效率
3. 反范式化需要适度

### 维护和优化
1. 维护数据字典
   1. 用第三方工具来维护
   2. 本身的备注字段来维护(comment)
   3. mysql可以从information_schemas.TABLES和information_schemas.COLUMNS来联合查询出表和
   列的备注信息

2. 维护索引
   选择合适列建立索引
   1. where, group by, order by中出现的列
   2. 可选择性高的列放到索引前面
   3. 索引中不要包括太长的数据类型
   4. 索引不是越多越好
   5. 定期维护索引碎片
   6. sql中不要使用强制索引关键字

3. 维护表结构
   1. 使用在线表结构变更工具
   mysql 5.5前使用工具pt-online-schema-change,它通过生成临时表来进行变更，如果原表存在触发
   器，该工具无法生成新的触发器从而无法使用。
   mysql 5.6后本身支持在线表结构变更。

   2. 同时维护数据字典

   3. 控制表的宽度和大小

   4. 数据库适合批量操作，逐条操作适合在程序中操作。

   5. 禁止使用select * 查询

   6. 控制用户使用自定义函数

   7. 不要使用数据库中的全文索引,可以使用第三方的搜索引擎。

4. 适当时候需要水平拆分或垂直拆分
水平拆分是数据的拆分，可以按主键取模的方式拆分，查询和插入时也进行取模后再操作，垂直拆分
为列的拆分。
垂直拆分:
   1. 经常一起查询的列放到一起。
   2. text,blob等大字段拆分出到附加表中。


<hr />
<img src="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/20190304_1.jpg" class="full-image" />
