---
title: 工具小技巧合集
categories: Tool
tags:
  - Eclipse
  - Sublime Text
  - IntelliJ Idea
  - Maven
  - Vim
  - Babun
  - Git
  - Windows10
  - MacOS
  - Karabiner
  - CORS
  - Shell
  - Ubantu
  - Vmware workstation
image: 'http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/201901311.jpg'
abbrlink: 398a782a
updated: 2019-09-17 14:30:28
date: 2019-02-11 14:31:10
---
自己总结的工具小技巧: Eclipse, Sublime Text, IntelliJ Idea, Maven, Vim, Babun, Git,
Windows10,Karabiner
<!-- more -->
## eclipse windows快捷键
下载eclipse安装包应注意选择javaEE版，它里面自带了maven插件。
注：如可以下载eclipse vim插件，以下快捷键设置可以不用看。
```txt
向上 line up     ctrl+k
向下 line down   ctrl+j
左 previous column  ctrl+h
右 next column  ctrl+L<go to line>
alt+j     incremental find
alt+k    find next
智能提示 .abcd....
字体
背景色 general-editors-text editors

Ctrl+a      line start
Ctrl+u    Line end
Ctrl+i     Correct indentation 自动缩进
给本地变量赋值 quick assist assign to local variable    ctrl+2,L改为ctrl+p

ctrl+z  undo the last operation
ctrl+y redo the last operation
全选ctrl+a变为ctrl+shift+a

show in(package explorer)   alt+1
when editing java source

show view console   alt+c
show view package explorer  alt+p

ctrl + backspace 向前删除一个单词
ctrl + delete 向后删除一个单词

分割窗口 在window下选择new window
然后利用windows系统快捷键window+方向键
控制窗口布局

ultraEdit分割窗口
“高级”菜单→配置→应用程序布局→文件标签→操作→取掉勾选“可吸附标签”→应用→确定
再进行鼠标拖动到滚动条附近即可
```
## sublimeText json格式化
安装插件Pretty Json, 格式化json文件快捷键
```txt
windows: ctrl + alt + j 
macOS:   ctrl + command + j
```
## IntelliJ Idea

   1. 将当前编辑区文件在package目录下定位显示出来
   使用插件Scroll From Source,定义快捷键为alt + 2,
   alt + 1是控制Package目录窗口显示开关。

   2. 在idea中使用vim模式可以下载插件IdeaVim,定义模式开关快捷键为F1。 

   ### Idea实现和Eclipse Workspace一样的多项目并列显示效果
   1. 新建一个空白文件夹ideaWorkspace.
   2. 将需要引入的项目代码拷贝到该文件夹下。
   3. 用idea open ideaWorkspace.
   4. 在右侧的Maven Projects视图中点击加号，用ctrl键多选刚才导入的各个项目的pom.xml文件。
   5. 可以点击刷新图标进行依赖更新。
   搞定！

## Maven
银行里有个jar包找不到，我以为是maven仓库里没有，跟银行里的人说了下，他又给了我2个mirror
地址，那么问题来了:
> 怎么在settings.xml里配置多个mirror同时起作用？
> mirrorOf是什么意思？
> repository和mirror的区别是什么？

经过搜索和官方文档，总结如下：
   1. repository是存储多个jar包的仓库，maven默认是去center仓库下载jar包。
   2. mirror是repository的复制镜像，由于网速等其他原因用来替代原始仓库，mirror下的mirrorId指定
了复制的的repository的ID,而mirrorId是唯一的。
   3. 在mirrorOf里可以使用如`*`,`*,!repo1`来控制多个镜像时具体哪一个生效的问题,这里判断的依据
就是repository id,
> When you use the advanced syntax and configure multiple mirrors, keep in mind that 
> their declaration order matters. When Maven looks for a mirror of some repository, it 
> first checks for a mirror whose <mirrorOf> exactly matches the repository identifier. 
> If no direct match is found, Maven picks the first mirror declaration that matches 
> according to the rules above (if any). Hence, you may influence match order by changing 
> the order of the definitions in the settings.xml

就是说它先是寻找最匹配的，再按顺序查找其他匹配的。
> As of Maven 3.x, repositories are searched in the order in which they are declared.
具体实战settings.xml如下
```txt
<mirrors>
  <mirror>  
       <id>alimaven</id>  
       <name>aliyun maven</name>  
       <url>http://maven.aliyun.com/nexus/content/groups/public/</url>  
       <mirrorOf>central</mirrorOf>          
   </mirror>
 </mirrors>
 <profiles>
    <profile>
      <id>nexus private</id>

      <repositories>
       <repository>
         <id>ccb</id>  
         <name>ccb</name>  
         <url>http://xxx.xxx.xxx:1280/nexus/content/groups/public/</url>  
       </repository>
     </repositories>
     <pluginRepositories>
       <pluginRepository>
         <id>ccb</id>  
         <name>ccb</name>  
         <url>http://xxx.xxx.xxx:1280/nexus/content/groups/public/</url>  
       </pluginRepository>
     </pluginRepositories>
   </profile>
 </profiles>
 <activeProfiles>
    <activeProfile>nexus private</activeProfile>
 </activeProfiles>
```
具体优先级为
> 本地local .m2/repository > 私服profile > 远程仓库 mirror和pom.xml中的repository

真正解决问题的是这篇文章，点赞！
[maven download jars](https://swenfang.github.io/2018/06/03/Maven-Priority/)
注： 可以用如`mvn -X dependency:tree`来查看maven debug信息。

nexus的作用就是替代中央仓库，完全自主控制公司或集团内部需要的下载的jar包，是提供了缓存作用
的maven仓库。
[how does a maven repository work?](https://blog.packagecloud.io/eng/2017/03/09/how-does-a-maven-repository-work/)
经过大半天折腾，我最后仔细的看了下那个没找到的jar包，原来就是现在这个多模块项目的子模块，
无语！
在相应目录下执行mvn install就好了。。。

2019.3.10加：
经返回查看书籍《maven实战》一书，查漏补缺知识总结如下:
1. mvn install即将自己的项目jar包安装到本地仓库
2. 远程仓库的配置
```txt
<repositories>
    <repository>
        <id></id>     <!--每个仓库id是唯一的-->
        <name></name>
        <url></url>
        <releases>
            <enabled>true</enabled> <!-- 可以下载release版本-->

            <!--默认daily-每天检查一次,其他有
            never - 从不更新
            always - 都更新
            interval: X - 每隔X分钟更新-->
            <updatePolicy>daily</updatePolicy> 

            <!--默认warn-构建时输出警告信息，其他有
            fail - 校验和错误时让构建失败
            ignore - 忽略校验和错误-->
            <checksumPolicy>warn</checksumPolicy> 
        </releases>
        <snapshots>
            <enabled>false</enabled> <!-- 不可以下载snapshots版本-->
            <updatePolicy>daily</updatePolicy> 
            <checksumPolicy>warn</checksumPolicy> 
        </snapshots>
        <layout>default</layout>   <!-- 布局为maven2或3,而不是maven 1的布局-->
    </repository>
<repositories>
```
3. 远程仓库需要认证时在settingsx.xml文件中配置server信息，id为repositoryId。
4. 将项目jar包部署到私服或其他远程仓库。
   1. 修改pom.xml文件
```txt
<distributionManagement>
    <repository>
        <id>proj-release</id>  <!--发布版本的仓库-->
        <name></name>
        <url></url>
    </repository>
    <snapshotRepository>
        <id>proj-snapshot</id>  <!--快照版本的仓库-->
        <name></name>
        <url></url>
    </snapshotRepository>
</distributionManagement>
```
   2. 从远程仓库下载jar包和部署jar包都需要认证，都是配置在settings.xml文件中。
   3. 执行命令`mvn clean deploy`,当前项目版本是release版本,maven会部署到发布版本仓库，
   当前项目若是snapshot版本，会被部署到快照版本仓库。
   > The Central Maven repository stores release artifacts. Snapshots capture a work 
   > in progress and are used during development. A Snapshot artifact has both a version 
   > number such as “1.3.0” or “1.3” and a timestamp.

   4. jar包版本是release或snapshot,latest时，maven首先需要根据远程仓库的更新策略来检查更新，
   `<release>`的`<enabled>`,`<updatePolicy>`的值来确定是否允许下载和是否检查更新（可以在命令行里
   使用-U来强制更新)。由于release,latest容易版本问题导致构建失败，所以maven 3中已经取消了
   对它们的支持，实际使用还是以具体版本号较多。

   5. 镜像仓库完全屏蔽了原仓库，当镜像不可用时，maven无法访问原仓库，所以此时无法下载jar包。

   6. 生命周期是maven自己定义的概念，具体的操作由不同的maven插件来执行，相当于设计模式里的
   模版方法。

   7. maven有3套相互独立的生命周期: clean(清理项目)、default(构建项目)、 site(建立项目站点),
   每套生命周期内部的阶段phase前后有依赖关系,某个生命周期的phase的执行对其他生命周期的phase
   没有影响。`mvn clean install`执行了clean生命周期的pre-clean,clean阶段，default生命周期的
   从validate到install的所有阶段。
  `mvn clean deploy site-deploy`实际执行了clean的pre-clean,clean阶段，default的所有阶段，
  site生命周期的所有阶段。
  > clean： pre-clean, clean, post-clean
  > site： pre-site, site, post-site, site-deploy
  > default: validate - initialize - resources - compile - test resources -
  > test compile - test - package - integration test - verify - install -deploy
  >
  > default基本流程为:
  > 初始化 - 处理主资源文件-编译主源码-处理测试资源文件-编译测试源码- 
  > 执行测试 - 打包 - 集成测试 - 验证 - 项目jar包安装到本地仓库 - 部署到远程仓库

  8. 单个maven插件可以完成多个功能。由于这些功能有很多可以复用的代码，所以将它们集合到一个
  插件中，每个功能点就是一个插件目标plugin goal,如命令`mvn dependency:tree`就是调用了插件
  maven-dependency-plugin的插件目标:列出项目依赖树。`mvn compiler:compile`是插件maven-
  compiler-plugin的compile目标。

  9. maven通过将生命周期阶段和对应的插件目标进行绑定从而实现具体的构建任务。如clean生命周期
  的clean阶段和maven-clean-plugin的clean阶段是默认绑定在一起的。clean生命力周期的pre-clean和
  post-clean阶段由于没有默认绑定插件目标，所以它们没有实际的行为。

  10. 可以自定义插件目标绑定到生命周期的某个阶段中，如可以将插件maven-source-plugin的jar-
  no-fork目标绑定到default生命周期的verify阶段从而实现在该阶段创建出项目的源码jar包。
  ```txt
  <build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-source-plugin</artifactId>
            <version>2.1.1</version>
            <executions>
                <execution>
                    <id>attach-sources</id>
                    <!--如该phase配置省略，jar-no-fork默认绑定到package阶段执行-->
                    <phase>verify</phase> 
                    <goals>
                        <goal>jar-no-fork</goal>
                    </goals>
                </execution>
            </executions>
        </plugin>
    </plugin>
  </build>
  ```

  11. 插件配置。
     1. 可以在命令行进行配置，如命令`mvn install -DskipTests`就是在执行default生命
  周期从开始到install阶段的过程中跳过test阶段。
     2. 可以在pom声明该插件时配置该插件的某些全局属性，如maven-compiler-plugin的jdk
  版本。
  ```txt
  <build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-compile-plugin</artifactId>
            <version>2.1</version>
            <configuration>
                <source>1.7</source> <!--编译jdk1.7版本的源文件-->
                <target>1.7</target> <!--生成与jdk1.7版本兼容的字节码文件-->
            </configuration>
        </plugin>
    </plugin>
  </build>
  ```
    3. 还可以针对插件目标绑定到某个生命周期阶段的具体任务进行插件配置。此时
    `<configration>`配置节点位于具体的`<execution>`节点下。

  12. 命令行里执行`mvn -h`可以看到其基本使用方法为`mvn option goal phase`,option为mvn命令
  执行时的一些参数，如-X等，goal为插件目标，如命令`mvn dependency:tree`,即mvn是可以直接从
  命令行调用插件目标的，这适用于那些不方便绑定到某个生命周期阶段的插件目标，如help:describe,
  dependency:tree等，其中help,dependecy叫做插件前缀，用来代替插件的groupId,artifactId,version
  信息,maven对前缀的解析分为几个步骤：
     1. maven有默认的groupId,有org.apache.maven.plugin, org.codehaus.mojo2个groupId,还可以
     在settings.xml文件的`<pluginGroups>`中配置自己的插件仓库groupId.
     2. 依赖的元数据位于groupId/artifactId/maven-metadata.xml中，插件的元数据位于groupId/
     maven-metadata.xml中，其中定义了每个插件前缀和artifactId的映射关系。
     3. 核心插件版本在超级pom中已经设定好了，而对于非核心插件并且没有设定版本号的插件，
     maven 2会解析到latest版本，maven 3会解析到release版本，不过这样还是容易引起版本问题，
     所以还是推荐指定插件版本号。

  13. maven属性，一般常见的为pom.xml中定义属性
  ```txt
  <properties>
    <spring.version>4.5</spring.version>
  </properties>
  # 依赖中就可以使用${spring.version}来替代具体的版本
  ```
  14. maven资源过滤，针对如src/main/resources资源目录下的文件，如指定不同环境的数据库JDBC
  配置,需要根据环境切换，和spring的profile类似，maven也提供了相同的功能。
     1. maven的profile可以在pom.xml文件，user/.m2/settings.xml文件(针对当前用户有效)，
     maven安装目录/conf/settings.xml文件(针对本机所有用户有效)这3个文件中定义，其中
     pom.xml文件由于可以加入版本控制，利于移植，所以pom.xml文件中profile可配置的属性最多，
     有repository,dependency,depencymanagement,build中的plugin,resource等，而
     settings.xml中的profile由于不方便分享，所以只能配置仓库和属性值。
     2. 在profile中定义不同环境的profile,如每个profile都有自己的JDBC配置，如db.url属性
     每个profile的值都不相同，然后在application.yml中使用${db.url}来替代具体的属性值，
     但是资源文件处理是由插件maven-resources-plugin处理的，但它功能是将项目的主资源文件
     复制到主代码编译输出目录，测试资源文件复制到测试代码编译输出目录，即它不会解析具体
     的${db.url}的值，所以我们需要在pom.xml中进行配置告诉它进行属性解析。
     ```txt
     <build>
         <resouces>
            <resource>
                <directory>${project.basedir}/src/main/resources</directory>
                <filtering>true</filtering>
            </resource>
         </resouces>
     </build>
     ```
     测试资源目录配置相同,目录由main改成test即可。
     3. 最后，激活需要使用的profile即可得到需要的配置属性。
       1. 命令行激活 `mvn clean install -Pdev`激活了dev profile.
       2. settings.xml文件中`<activeProfiles>`配置来永久激活某些profile.
       3. 系统属性，操作系统不同，某个文件存在与否都可以用来判断是否激活某个profile.
       4. 默认激活，在以上方式没有任何一种已经激活的情况下，选择默认激活，`<profile>`下
       的`<activation><activeByDefault>true</activeByDefault></activation>`来默认激活。

  15. web资源过滤，对于src/main/webapp目录的资源如果也想开启资源过滤解析属性功能时，
  由于它是有插件maven-war-plugin控制的，所以需要对该插件进行配置。
  ```txt
  <profiles>
    <profile>
        <id>client-a</id>
        <properties>
            <client.logo>a.jpg</client.logo>
            <client.theme>red</client.theme>
        </properties>
    </profile>
    <profile>
        <id>client-b</id>
        <properties>
            <client.logo>b.jpg</client.logo>
            <client.theme>blue</client.theme>
        </properties>
    </profile>
 </profiles>

<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-war-plugin</artifactId>
    <version>2.1-beta-1</version>
    <configuration>
        <webResources>
            <resource>
                <filtering>true</filtering>
                <directory>src/main/webapp</directory>
                <includes>
                    <include>**/*.css</include>
                    <include>**/*.js</include>
                </includes>
            </resource>
        </webResources>
    </configuration>
</plugin>
  ```
  16. 聚合
  聚合的作用是可以一条maven命令同时构建多个项目。

  maven聚合模块的groupId, versionId一般与被聚模块相同，聚合模块的打包方式packaging不能为
  jar或war，必须为pom.
  module元素的值代表的是被聚模块的相对路径，如聚合模块pom路径为D:/code/parent/pom.xml,module
  为`<module>module1</module>`，代表它有被聚模块D:/code/parent/module1（即这个值代表的是目录名）
  module1有自己的pom.xml,src/main/java, src/test/java等，可以独立构建。
  以上是父子目录结构，如果是平行结构，即聚合模块和被聚模块处于同级目录下时，module为
  `<module>../module1</module>`.

  17. 继承
  继承的作用是消除重复，包括依赖，插件等。

  与聚合相同，父模块的packaging也必须为pom，它也不需要pom.xml之外的src/main等文件，只是为
  了消除重复。继承体现在子模块pom.xml的parent元素中。

  父项目中使用dependencyManagement元素可以定义统一的依赖groupId,artifactId,version和scope,
  它并不会实际引入依赖，子模块中只需要定义groupId和artifactId即可引入该依赖，version和
  scope由dependencyManagement继承而来，这样统一管理了依赖版本。

  可以继承的pom元素主要有
  `groupId,versionId,properties,dependencies,dependencyManagement,repositories,build`
  
  其中dependencyManagement除了可以复制和继承来实现复用外，还可以通过`<scope>import</scope>`
  来引入。即import只有在dm元素下生效，将另一个dm内容引入到当前的dm中。
 ```txt
 <dependencyManagement>
      <dependencies>
          <dependency>
              <groupId>org.springframework.cloud</groupId>
              <artifactId>spring-cloud-dependencies</artifactId>
              <version>${spring-cloud.version}</version>

              <-- import的都是pom packaging-->
              <type>pom</type>
              <scope>import</scope>

          </dependency>
      </dependencies>
  </dependencyManagement>
 ```

类似的，插件也有依赖管理pluginManagement,对一些核心插件的配置，如maven-compiler-plugin
对编译jdk版本的控制，maven-resources-plugin对编码格式定为utf-8的控制等，可以在父模块中
定义即可，插件完全不用配置即可使用该插件，原因如下：
1. 生命周期默认绑定的插件不需要显式的配置。
2. 超级pom定义了这些默认插件的版本。
3. pluginManagement定义了这些插件的行为。

经测试，父项目中直接定义plugins标签，子模块可以继承得到该插件。

  18. 聚合与继承
  聚合与继承目地不同，聚合只要聚合模块知道哪些被聚合了，继承只有子模块知道自己的父模块。
  实际开发中为了方便，通常会将聚合与继承合为一个项目。即该父pom中元素有module,properties,
  dependencyManagement,pluginManagement.

  19. maven的约定
  maven默认的java源代码目录是src/main/java,测试源代码目录src/test/java,这个约定是在maven的
  超级pom中定义的，maven3的super pom位置为$MAVEN_HOME/lib/maven-model-builder-x.x.x.jar中。

  20. maven依赖传递总结
  相同依赖不同版本的调解原则：
     1. 就近原则，离根路径短者优先。
     2. 声明优先，路径相同时先声明者优先。
  传递范围：
  compile: 默认范围，编译，测试，运行都有效
  test:   只对测试时有效，编译和运行无效，如junit
  provided: 编译和测试有效，运行无效，如servlet api,运行时外部容器tomcat等已提供。
  runtime:  测试和运行有效，编译时无效， 如jdbc驱动的实现类，编译时只需要接口，运行时才需要实现。

  依赖传递表左边一列是第一依赖，上面一行是第2依赖。
  简单总结为：
     1. 第二依赖为compile时，传递依赖范围以第一依赖为准。
     2. 第二依赖为test时，无法传递。
     3. 第二依赖为provided时，只有第一依赖也为provided可以传递，其他范围不能传递。
     4. 第二依赖为runtime时，范围以第一依赖为准，除了第一依赖为compile时，其范围为runtime.

  依赖优化：
     1. 使用exclude标签去除冲突的依赖。
     2. 使用properties标签统一依赖版本号。
     3. 使用mvn dependency:list, tree, analyze查看依赖情况。

  21. 反应堆
  在一个多模块项目中，如上层目录是聚合模块，父项目是其他子模块的平级目录，则从聚合模块中
  执行`mvn clean install`命令时，maven会按照一定顺序确定构建的顺序，
  即所有模块构成的构建结构叫做反应堆（reactor),该顺序为反应堆的构建顺序。
  
  maven按顺序构建pom,如果该模块有依赖，则先构建依赖，如果该依赖还有前置依赖，则也先构建该
  前置依赖，依次类推。

  如果想一次构建所有项目时，直接执行`mvn clean install`即可，如果模块非常多，想一次构建
  其中部分模块，跑到每个模块下执行该命令过于麻烦，可以在父目录下带上命令行参数实时裁剪
  反应堆，这里记录下以供以后使用。
```txt
使用mvn -h查看
mvn clean install
-pl  --projects  构建指定的模块列表，用逗号分割，只会构建模块本身，不构建依赖或下属
-am  --also-make 同时构建它依赖的模块，如构建子模块时，会同时构建父模块parent
-amd -also-make-dependents  同时构建下属依赖，如构建父模块时，会同时构建所有子模块
-rf  -resume-from  在已有反应堆顺序的基础上，可以指定从某个模块开始构建
可以在-pl,-am,-amd的基础上使用-rf来精确控制。
```

2019-08-02 14:58:50 添加:
最近项目上经常因为某些包有安全漏洞需要升级版本，但由于银行内部的nexus仓库没有最新的版本
或者说依赖包不全，这时候就需要链接外网到阿里的镜像仓库中下载，这时问题来了，如何编写maven
配置文件settings.xml使得通过ali镜像下载的包可以和通过内网下载的包一起生效？

问题背景是工作是用的虚拟机，虚拟机设置的是按特定网卡链接到虚拟机(还是搞不太清楚具体的虚拟
机网络配置), 总之，外网和内网不能同时访问。

链接外网时，将内网的repository注释掉时发现aliyun还下载了其他不需要更新的包。
所以个人认为，下载的包中有记录该包所属的仓库信息，需要在settings配置中保留内网的repository,
这样maven就不会到新仓库中去下载本地已有的包了。
所以使用以下配置即可，以后无论链接内网或外网，都不应当也不需要更改配置:
```txt
<mirrors>
  <mirror>  
       <id>publicRepo</id>  
       <name>publicRepo</name>  
       <url>内网</url>  
       <mirrorOf>central</mirrorOf>          
   </mirror>
 </mirrors>
 <profiles>
    <profile>
      <id>nexus private</id>
      <repositories>

       <repository>
         <id>ccb</id>  
         <name>ccb</name>  
         <url>内网1</url>  
       </repository>
       <repository>
         <id>ccb2</id>  
         <name>ccb2</name>  
         <url>内网2</url>  
       </repository>
       <!--  其他更多内网url地址， 最后放外网的aliyun地址，这样就可以最大程序利用
       已经有的本地jar包，不用重复下载-->
       <repository>
         <id>alimaven</id>  
         <name>aliyun maven</name>  
         <url>http://maven.aliyun.com/nexus/content/groups/public/</url>  
       </repository>

     </repositories>
   </profile>
 </profiles>
 <activeProfiles>
    <activeProfile>nexus private</activeProfile>
 </activeProfiles>
```
2019-08-05 14:35:24添加:
还是以上的版本升级问题，相应jar包下载成功后，在pom.xml中指定要升级的特定版本，结果项目启动
报错，无法初始化ObjectMapper类。
网上说maven编译成功，但运行报错的情况，还是jar包依赖有冲突。这次是要升级jackson-databind
版本到2.9.9.2，使用mvn dependency:tree命令发现它依赖的jackson-core和jackson-annotation还是
旧版本，查看2.9.9.2的pom文件找到它依赖的core和annotation具体版本，指定以后项目启动成功！

注: 以上就是解决问题的具体办法，在网上搜索的过程中，如果是自己的项目需要升级springboot中的
某个版本，网上说首先是升级springboot本身的版本，这也是最安全的。其次就是在自己的pom.xml使用
properties配置项指定要升级的版本，这样也不需要自己声明依赖，也比较安全。最后实在无法解决，
才是自己显式的声明依赖版本。

由于maven依赖的就近原则和声明优先原则，所以依赖的版本有冲突时会被忽略，但升级依赖时冲突的
依赖关系会留下隐患(如上面的maven编译成功，运行报错的情况),所以可以使用
`mvn dependency:tree -Dverbose -Dincludes=groupId:artifactId`来查看某个依赖的重复引入情况，
-Dincludes选项省略即为全部依赖的情况。

由以上问题也可以看出，当子模块继承了父模块时，当子摸块没有具体指明依赖版本时就会使用父模块的
dependencyManagement对子模块影响很大，这对于依赖传递也是同样的效果，所以出问题时可以通过
mvn dependency:tree命令查看具体的依赖版本是否正确。

## Vim
Vim自从去年年初开始学习以来，一直被我认为是编辑器之神,不说其他，光是最基本的h,j,k,l光标
移动就可以称得上是惊世神作！我在eclipse,Idea中也都下载了可以支持vim操作的插件，确实太
强了。
最近用vim写博客，因为图片地址的问题，需要用到vim的批量替换，正则表达式之前我还专门学习
过perl方面的东西，vim里好像有点不一样，今天上网搜了下，确实和perl有不同。

全文替换基本命令
> :%s/abc/wtt/g
> :%s#abc#wtt/g
> :%s@abc@wtt@g

还可以使用其他分隔符，以上3种应该够用了。

选中文本内替换,这里可以用可视模式选中后，再输入:s即可
> :'<,'>s/abc/wtt/g

vim的正则表达式

vim的元字符vim默认需要在前面加上\,但是可以设置模式
vim可以设置
> :set magic      # 除了^ $ . * 外其他元字符都需要\
:set nomagic      # 除了^ $ 外其他元字符都需要\

还可以在命令前临时切换
> /\m.*  # magic模式 查找任意字符串
/\M.*  # nomagic模式 查找.*字符串
\v   # very magic 模式 任意元字符都不用加\
\V   # very nomagic模式  任意元字符都要加\

> /\v(a.c){3}$ # 查找行尾的abcaccadc very magic 括号，点号，大括号全部识别成功，3个字母重复3次
/\m(a.c){3}$ # 查找行尾的(abc){3}    magic  括号和大括号未识别成功,点号和结尾符识别成功
/\M(a.c){3}$ # 查找行尾的(a.c){3}    nomagic 只有结尾符识别成功，其他都是原符号
/\V(a.c){3}$ # 查找任意位置的(a.c){3}$  very nomagic  全部都匹配原字符
:s/\v(cll)/\1##/g     使用\m,\v等修饰符时需要放在第一个分隔符后，待处理字符串前面

vim默认是magic模式,这也意味着用vim写正则表达式来搜索或替换时，除了开头结尾^$和.*以外，
经测试magic模式下字符组[]也不用加\,想使用其他元字符需要在前面加上\，但也有例外，具体常用如下
> 捕获括号\(\)  前后都要加\
> 字符组[]   字符组反而都不用加\,加了还报错
> \{n,m}  这个经过测试，前面加一个\就行，加2个也可以，为了规范好记，还是加2个吧
> \+   一个或多个
> \?   0个或1个

vim非贪婪匹配(lazy match)
贪婪的.*变为.\{-}
常用的和perl比较如下
```txt
perl     vim
*        *
+        \+
?       \? or \=
{n,m}     \{n,m}
{n,}      \{n,}
{,m}      \{,m}
{n}       \{n}
{n,m}?    \{-n,m}    n到m个 忽略优先
*?        \{-}       0个或多个 忽略优先
+?        \{-1,}     1个或多个 忽略优先 
??        \-{,1}     0个或1个  忽略优先
```

vim还支持环视和固化分组功能
这里先记下，等以后需要时可以尝试使用
```txt
perl     vim
(?=     \@=      正向肯定环视
(?!     \@!      正向否定环视
(?<=    \@<=     反向肯定环视
(?<!    \@<!     反向否定环视
(?>     \@>      固化分组
(?:     \%(atom\)  相比正常的捕获型括号,前面一个括号加了一个%号
```
匹配foobar中的bar,用环视来写
```txt
perl:  /(?<=foo)bar/     # 需要判断的字符在环视符号内部
vim:  /\(foo\)\@<=bar/   # 需要判断的字符在环视符号前面
```

vim: maximize help tab  ctrl+w _ 发现途径 vim help文档
:h 
forward   ctrl + ]
backward  ctrl + o

vim寄存器
用：reg命令查看寄存器内容
"" 匿名寄存器 set clipboard=unnamed 即是将系统剪贴板与匿名寄存器绑定到一起了
"0 复制内容寄存器
"- 小删除寄存器
"1 - "9 行级以上删除寄存器
":  上一个vim命令寄存器
"/  上一个搜索内容寄存器

vim中先复制然后进行替换时，用d或s顶替了匿名寄存器""中的内容，
复制的时候内容会存到“0寄存器中，同时会同步到匿名寄存器中，
所以替换的时候如果用d，s删除旧内容后，可以用"0p来粘贴复制的新内容。
"0是记录上一个复制的内容，如果想实现多个复制记录表，
可以使用命名寄存器"a -> "z
复制时指定寄存器  "ay
粘贴时也指定寄存器  "ap
一般用到a,b,c就够用了。

清楚a寄存器可以使用命令qaq
这里是录制一个空的宏命令。

粘贴最近复制的内容快捷键设置:
```txt
noremap <leader>v "0p
noremap <leader>V "0Pl
```

使用`<leader>`V时可以看到，粘贴内容粘贴在光标位置前，光标后内容自动向后移动。

vim将一列内容复制到另一列的结尾，
**vim块选择模式支持，ideaVim插件还不能支持该功能,sublimeText也不支持**
ctrl+v选择要粘贴的部分  d
到第一列第一行的结尾处 a  space p

在编辑文章时，可以使用'.跳转到上一个编辑修改的位置，
再用g;来跳转到更老的编辑位置。

写markdown时用`>`有些字符如`*`会被当成md符号进行渲染从而显示不出来，所以还是多用文本引用，
这里特定定义了vim键位映射来方便书写
```txt
map <leader>` i```txt<CR>```<Esc>O<Esc>
```

因为`$`键需要按2个键，在命令模式和可视模式下确实不方便，所以看了看选择m键代替
```txt
noremap m $
vnoremap m $
```
vim对选中的可视区域块内进行替换操作，相当于eclipse或idea中replace in selection功能
```txt
在正则表达式前加上\%V修饰符，如
'<,'>s/\%Vwtt/GOGOGO/g
同理，在选中区域内搜索也是一样，t
'<,'>/\%Vwtt
```

vim在匹配行前新增一行，使用\r
%s!\v(private String (.*);.*)!@JsonProperty("\2")\r\1!g

2019-04-24 16:57:49
工作中经常要面对一个小任务，删除文本中重复出现的单词，
网上搜了一下，发现vim的神命令
`:sort u`
该命令会将所有行进行排序，并删除重复的行，(该命令也可以快速空行，不用麻烦的%s/^$\n//g)
所以在使用该命令前，将每个单词单独列为一行即可。
`%s/\>/\r/g`

2019-08-22 09:26:12 添加:
有时候需要同时编辑多个文件(在ide中可以使用快捷键切换——这是ide最重要的功能之一)，
vim可以使用以下2种方法:
1. 先打开一个文件，然后使用`:sp fileName`(水平分割)或`:vs fileName`(垂直分割)来分割窗口
打开另外一个文件，该功能适合需要同时看到多个文件的场景，如比较并操作等。
2. 使用命令`vi -o fileName1 fileName2`(水平分割)或`vi -O fileName1 fileName2`(垂直分割)
实现以上相同的功能。
3. 使用命令`vi -p fileName1 fileName2`可以打开多个tab页，使用命令`gt`和`gT`进行切换。 
注: 如果需要只读方式打开一个文件(防止误修改), 可以使用命令`vi -m fileName`，它允许修改，但
无法保存。命令`vi -M fileName`更进一步，无法进行任何改动。一般只查看时使用`-M`即可。
view命令修改时只会给出警告，还是可以使用命令如`:w!`进行修改。

2019-09-17 15:01:36 添加:
通过指定行数来选择大段的文本的方法。
由于之前写的JavaCoreNote的长文实在太长，最近想用typora导出pdf发现太大会崩溃，所以需要将
这个大文件拆分，但如何快速选择其中一大段文本呢。可以利用vim提供的标记mark来实现。
```txt
for example: select line 5 to 10
:5
ma   # make mark at line 5
:10
shift + v # enter line selection mode
'a   # go to mark! done!
```
经测试，ma始终没有效果，最后突然想起来我把它映射成$了，难怪没有效果...(m都用了好久了....)
现在将$改为`<leader>l`.
小写的标记是在当前编辑文件的buffer中使用，如'a是跳到标记的那一行，\`a是跳到那一行，那一列，
相对来说更精确，而使用大写的标记如mA则是标记某一个文件中的位置。
每一个文件可以有自己的a标记，但所有文件中只能有一个A标记(大写标记是唯一的), 重复定义大写
会覆盖之前的大写标记。可以利用大写标记配合vim tab来快速编辑多个文件，这样就不用使用麻烦的
gt切换标签了。

可以使用:marks来查看所有标记.使用:delmarks aA删除标记a和A, :delmarks!删除所有小写标记。

2019-09-18 14:06:54 添加:
vim中换行符在匹配表达式中是\n, 用于替换的文本为\r, :%s表示的是全文替换, 默认的:s是单行模式,
所以可以测试出如果表达式使用了换行符\n, 必须使用%来进行全文匹配才可以生效。
同时使用默认的^和$时匹配的是光标所在行的开头和结尾，使用%就是每一行的开头和结尾，若需要
全文开头和全文结尾，可以使用\A和\Z.
下面是我将自己的博客转化为pdf时使用vim正则表达式进行处理后转移到sed命令中的例子。
```txt
// vim
%s#<img src=".*"\s*/>##
%s#!\[.*\](.*)##
%s@<hr\s*/>@@g
%s@<!-- more -->@@g
%s@---@```@g
%s@\v(```\ntitle:(.*))@#\2\r\1@g
s@\A@[toc]\r\r@

// sed  开启扩展模式-r, 元字符无需转义 如?, +, {}, | 同vim的\v very magic模式基本是相同的
sed -i 's#<img src=".*"\s*/>##g' taoblog${now}.md
sed -i 's#!\[.*\](.*)##g' taoblog${now}.md
sed -i 's@<hr\s*/>@@g' taoblog${now}.md
sed -i 's@---@```@g' taoblog${now}.md
sed -i 's@<!--\s*more\s*-->@@g' taoblog${now}.md

# sed默认是单行模式，虽然它也支持多行模式，但涉及很多sed本身的语法，所以为了简便，这里使用
# 学习正则表达式时就接触的perl. 如下sed语句是无效的.
#sed -ir 's@(```\ntitle:(.*))@#\2\r\1@g' taoblog${now}.md
# perl --version   perl 5, version 26
perl -0777 -pi -e 's@(```\ntitle:(.*))@#$2\n$1@g' test
# 最后加上目录标签，方便typora渲染 sed不支持\A
# sed -i 's@\A@[toc]\r\r@' taoblog${now}.md
sed -i '1s@^@[toc]\n\n@' taoblog${now}.md

```
其中在文件开头添加文本除了可以使用\A匹配外，还可以使用cat命令来做。
```txt
// 读取输入 输出到新文件
cat <(echo "before") text.txt > newfile.txt
(echo "to be prepended"; cat text.txt) > newfile.txt
```

另外sed功能还是十分强大的，结合管道符可以进行很多文件处理。如之前我使用vim的mark标记来
拆分长篇博客为短篇文章,完全可以使用sed来完成拆分工作。
如t1文件如下:
```txt
1ss
2sfsdfsd
3sfsdfsdfsdf
4xx
```
我想将t1文件的2到3行内容剪贴到t2文件中，可以使用以下命令

`sed -n '2,3p' t1 >> t2; sed -i '2,3d' t1`

其中-n是silent模式，屏蔽掉自动打印匹配内容，只打印2,3p匹配的内容, 追加到t2后，再紧接着
执行-i '2,3d'操作来删除2,3行内容。简单的'2,3dp'是不支持的，还是要将剪贴操作分为复制和删除
两个操作。

perl处理多行相关参数总结:
可以开启perl的debug模式输出匹配过程，利于表达式的调试，e.g.,

`perl -Mre=debug -pi -e 's/^```\ntitle/HH/s' test`
但它输出的内容很多，可读性不好，网上搜索到perl有个Debugger模块实现了可视化的正则表达式调试
过程，需要先安装该模块。
```txt
cpan   # ubuntu 18.04下可以直接输入，已经预先安装好build-essential
# 第一次运行会提示配置和下载cpan相关内容。
make install
install Bundle::CPAN
install Regexp::Debugger 
```
装好以后，直接输入rxrx即可进入调试界面，用/regexp/输入正则表达式，'string'输入要匹配的字符
串，d解析表达式内容，m进行匹配。匹配时按?可以查看帮助。


perl默认也是按行读取处理的(毕竟这是最常见的场景), 但我需要在每一篇博客上加一个`#`标签，
这就涉及到多行读取进行匹配。sed的语法比较晦涩，perl稍微好点，但也需要指定。
```txt
perl -0777 -pi -e 's@(```\ntitle:(.*))@#$2\n$1@g' test
```
-0777 即指定perl多行读取(关键参数!)
The special value 00 will cause Perl to slurp files in paragraph mode. 
Any value 0400 or above will cause Perl to slurp files whole, but by convention the 
value 0777 is the one normally used for this purpose.

-p print code execution result
-i make changes take place in the file 同sed
-e execute code snippet behind, no need to write a file to run perl
表达式最后的模式修饰符

/m /s的区别和用途
```txt
no modifiers: Default behavior. '.' matches any character except "\n" . 
'^' matches only at the beginning of the string and '$' matches only at the end or 
before a newline at the end.

s modifier (/s ): Treat string as a single long line. '.' matches any character, 
even "\n" . '^' matches only at the beginning of the string and '$' matches only at 
the end or before a newline at the end.

m modifier (/m ): Treat string as a set of multiple lines. '.' matches any character 
except "\n" . '^' and '$' are able to match at the start or end of any line within the string.

both s and m modifiers (/sm ): Treat string as a single long line, but detect multiple lines. 
'.' matches any character, even "\n" . '^' and '$' , however, are able to match at the 
start or end of any line within the string. 
```

/g和/c的使用
```txt
The modifier /g stands for global matching and allows the matching operator to match 
within a string as many times as possible. In scalar context, successive invocations 
against a string will have /g jump from match to match, keeping track of position in the 
string as it goes along. You can get or set the position with the pos() function.

A failed match or changing the target string resets the position. If you don't want the 
position reset after failure to match, add the /c , as in /regexp/gc . The current position 
in the string is associated with the string, not the regexp. This means that different 
strings have different positions and their respective positions can be set or read independently.
```
/c在匹配失败时不会重置位置(它和被匹配的文本是同步的), 适合与同一段文本用不同的正则表达式
进行匹配。

/G是和/g配合使用。
```txt
The \G anchor matches at the point where the previous /g match left off. 
\G allows us to easily do context-sensitive matching.
The combination of /g and \G allows us to process the string a bit at a time and use 
arbitrary Perl logic to decide what to do next. Currently, the \G anchor is only fully 
supported when used to anchor to the start of the pattern.
```
/x 提供了正则表达式的可读性，可以在表达式中添加注释。
/i 匹配时忽略大小写

/e 可以将新字符串变为perl代码
```txt
A modifier available specifically to search and replace is the s///e evaluation modifier. 
s///e treats the replacement text as Perl code, rather than a double-quoted string. 
The value that the code returns is substituted for the matched substring. s///e is useful 
if you need to do a bit of computation in the process of replacing text.
```

perl还提供了可以放在正则表达式内部的内嵌表达式。(总体来说，还是比较少使用到)
如(?# I am Comment) 可以替代/x来进行注释功能
```txt
Most modifiers, such as /i , /m , /s and /x (or any combination thereof) can also be 
embedded in a regexp using (?i) , (?m) , (?s) , and (?x)

Embedded modifiers can have two important advantages over the usual modifiers. 
1. Embedded modifiers allow a custom set of modifiers for each regexp pattern. 
This is great for matching an array of regexps that must have different modifiers.

2. The second advantage is that embedded modifiers (except /p , which modifies the 
entire regexp) only affect the regexp inside the group the embedded modifier is 
contained in. So grouping can be used to localize the modifier's effects.

besides: Embedded modifiers can also turn off any modifiers already present by using, 
e.g., (?-i) 
```

2019-10-11 12:47:42 添加:
vim 切换tab页用原生的gt,gT按的比较麻烦，可以映射成和terminator, gnome-terminal一样的切换
快捷键，以下为映射关系:
```txt
noremap <Leader>j gT
noremap <Leader>k gt
```
这样要比按g和t两个字母要方便，而且比按T要方便，而且j,k按键位置与tab的顺序保持了一致。
另外，vim本身提供了`<c-^>`或`<c-6>`支持在同一个window中来回切换最近修改的文件，非常适合
只需要同时编辑2个文件的情况。如编辑同一个文件夹下的jsp和js文件，
```txt
vi a.jsp
:e a.js
ctrl + 6
```
如果需要同时修改2个以上的文件，应当考虑使用ctrlP插件。ctrlP用来查找文件，再使用vim自带
的`:jumps`来实现跳转(ctrl + I/O组合键)，其中搜索，替换，标记(mark)都属于jump操作。
`:jumps`列表中`>`指示的是当前位置，按下第一列的数字后，如果要跳到`>`下面的位置，
使用ctrl + I向前跳(forward); 如果要跳到`>`上面的位置，使用ctrl + o向后跳(backward)。
使用`:clearjumps`清除jump列表，可以使用`:ju`和`:cle`来简化命令。
同理还有`:changes`显示修改列表，以前常用的跳到上一个修改位置的命令`g;`实际上就是在这个列表
上进行跳转。`g;`是backward, `g,`是forward. 类似与jumps, changes列表是首先输入第一列的数字，
再根据前后关系使用`g;`或`g,`即可。

注: 可以使用mark标签来确保某一行进入jump列表中。

other little useful notes:
1. `zf`可以将选中区域折叠起来(.vimrc中不能设置foldmethod=indent), 使用`za`来打开或关闭折叠。
2. vim可以将括号之间文本自动缩进，使用命令`=i{`, i 代表inner object. `>i{`扩大缩进距离，
`<i{`减小缩进距离。
3. vim自带的`:Explore`或`:Ex`可以查看文件目录，在没有nerdTree插件时很方便使用，可以使用
`:Texplore`在新tab页中打开目录列表。可以使用`:tabonly`只保留一个tab。
4. `A`在行尾插入字符，`I`在行首插入字符。(大写键用的少，偶尔使用非常方便。还有`F`用来反向
查找)
5. vim macro.宏实际使用的很少，但非常适合模块化操作，如简单的块操作模式无法生效时，如带有
正则表达式的时候。下面记录下macro的具体使用命令。如将以下文本中每一行的数字替换为`##`:
```txt
wtt23sdfsd
wttlsdf57sd
wt44tlsdfsd
```
命令如下
```txt
1. qa                  // 开始录制
2. :.s/\d\{2}/##/     // 操作 这里是替换，可以叠加任意多的操作
3. q                  // 结束录制
4. :reg               // 查看寄存a中的内容，即为录制的宏操作，
                     // 可以看到每一个按键(包括删除字符)都被记录在寄存器中
5. @@                // 重复前一次宏操作
5. '<,'>norm! @a     // 在选择块中执行宏a, normal命令: This makes it possible to execute 
                    // Normal mode commands typed on the command-line.  
                   //  {commands} are executed like they are typed.
                   // 5, 10norm! @a  在5到10行间执行norm命令
```
通过以上可以看到，macro很适合较简单的文本处理任务，如果更复杂或其他不适用的情况，应使用
sed或perl来处理。


## Babun
因为vimrc里的mapleader报错，发现babun里面的vim还是版本7的，于是用pact update vim来更新vim，结果
运行完成后命令vim没有反应，网上搜索说可以更新cygwin，babun update命令有问题，
可以手动更新babun from executing C：\Users\LYPC\.babun\update.bat

上面命令自动运行的cygwin下载速度太慢，还会卡死，所以还是自己来装....
1. 到官网上下在64位cygwin安装器，镜像地址 http://mirrors.sohu.com/cygwin/
2. [https://github.com/babun/babun/wiki/64-bit](https://github.com/babun/babun/wiki/64-bit/)

> cp -a /cygdrive/c/Users/LYPC/.babun/cygwin-32/home/ThinkPad-T540p/.* ~/
cp -a /cygdrive/c/Users/LYPC/.babun/cygwin-32/etc/{group,minttyrc,nanorc,passwd,vimrc} /etc
cp -a /cygdrive/c/Users/LYPC/.babun/cygwin-32/usr/local/bin/* /usr/local/bin/
cp -a /cygdrive/c/Users/LYPC/.babun/cygwin-32/usr/local/etc/* /usr/local/etc/
pact install gcc-core $(cat /usr/local/etc/babun/source/babun-packages/conf/cygwin.x86.packages | tr '\n' ' ')

pact install 下载地址可以添加镜像
我的是C:\Users\LYPC\.babun\cygwin\home\ThinkPad-T540p\.pact地址下修改pact.repo文件
将第一行默认的kernel注释掉，加上
> PACT_REPO=http://mirrors.sohu.com/cygwin/

执行babun install脚本时oh-my-zsh卡住了，找了个镜像可以用
https://bitbucket.org/zalew/oh-my-zsh-mirror.git

一通折腾过后，babun里vim变成了8.0.1567，但是mapleader还是报错，mac里也报错，看来是脚本本身的问题，不过目前使用
mapleader正常，看来不影响使用,vim的高级用法以后还是要多看看帮助文档，记录零散知识。

## Git
今天建行里面做了Git的简单培训，其中提到2个场景，因为以前也使用git,但对这2种场景具体处理办法
还不是很清楚，查询了他人的博客特地总结如下：
### 开发上线后产生了一个bug，当前还在开发新功能，如何回退到线上版本修改bug并提交？
其中最关键的是`git reflog`命令

1. 上线最好要打一个tag，方便以后回退版本，查看问题等
> git commit -m 'version 1.0'
> git tag v1.0

2. 这时已经开发到后面的功能，发现v1.0版本有bug,则进行回退修复处理，在出问题的master分支上
先找到v1.0的commitId
> git tag  # 查看所有tag
> git show v1.0  # 从中找出该tag的commitId
> git reset --hard commitId
> git checkout -b bugfix  # 新建bugfix分支
> git checkout master     # 先回master分支
> git reflog # reflog记录了最近几次的动作包括分支转换，从中找到git reset前最近一次
> 提交的commitId
> git reset --hard commitId    # 这时master分支回到起始状态
> 
> git checkout bugfix   # 切换回bugfix分支，面对的是干净的有bug的版本v1.0
> git add -a . && git commit -m 'bug fixed'  # 修改bug并提交
> git tag v1.1   # 可以打上标签为v1.1
> 
> git checkout master   # 切换回master
> git merge bugfix    # 合并bugfix内容
> 解决冲突后
> git add -A .    # 冲突的文件需要重新暂存
> git commit -m 'bug fixed'   # 解决bug
> 标签需要手动推送到远程仓库，可以使用命令
> git push origin --tags  # 推送所有tags到远程仓库

### 解决冲突
1. 合并后产生冲突，可以使用`git merge --abort`放弃这次合并，回到合并前的状态。
2. 使用合并工具`git mergetool`会调用一个可视化工具来解决冲突。
3. `git diff commitId...commitId`可以用来查看版本差异，可以手工找到共同祖先，拿到fetch后
的commitId.
4. `git show :1:filename`查看共同祖先的版本，`git show :2:filename`查看当前分支head版本，
`git show :3:filename`查看远程分支merged_head版本。

```txt
1. 多提交，少推送。多人协作时，推送会频繁地带来合并冲突的问题，影响效率。因此，
尽量多使用提交命令，减少合并的使用，这样会节省很多时间。
2. 使用Git流（Git Flow）。
3. 使用分支，保持主分支的整洁。这是我强烈推荐的一点，在分支进行提交，
然后切到主分支更新(git pull —rebase)，再合并分支、推送。这样的流程会避免交叉合并的情况出现
（不会出现共同祖先节点为多个的情况）。事实上，git合并操作让很多人感到不知所措的原因就是
各种原因所产生的交叉合并问题，从而造成在合并的过程中丢失某些代码。
保持主分支的整洁能够避免交叉合并的情况出现。
4. 禁用fast-forward模式。在拉取代码的时候使用rebase参数（前提是保持主分支的整洁）、
合并的时候使用—no-ff参数禁用fast-forward模式，这样做既能保证节点的清晰，
又避免了交叉合并的情况出现。
```
关于fast-foward
```txt
当前分支合并到另一分支时，如果没有分歧解决，就会直接移动文件指针。
这个过程叫做fast forward。
例如，开发一直在master分支进行，但忽然有一个新的想法，于是新建了一个develop的分支，
并在其上进行一系列提交，完成时，回到 master分支，此时，master分支在创建develop分支之后
并未产生任何新的commit。 此时的合并就叫fast forward.
可以看到master在合并develop分支的时候并没有产生新的节点回到develop分支，对代码进行修改，
提交。切换到master分支，使用git merge develop --no-ff 进行合并，此时会产生一个commit节点.
很明显使用--no-ff合并时，在删除develop分之后，该分支的合并信息仍然被保留，
在以后的代码分析中可以便捷的查看到历史信息，而fast forward方式则无法辨识代码的合并信息。
```
### Git分支模型使用总结
1. master分支是一个长期维护的主分支，主要作用是存储稳定的正式版本内容，数据来源于合并其他
分支(如develop,修复紧急bug的短期分支等)，合并完以后打上版本号即可以正式发布。
2. develop分支是另一个主分支，develop分支主要用来存储下个版本的最新变化,也不好用于直接干活，
可以用来合并其他短期分支(如某个功能分支，修复bug分支等).当版本稳定时，可以将develop分支合
并到master分支并打上标签作为新版本发布。
3. 用于真正干活的短期分支(如功能分支，修复bug分支等),完成后合并到develop分支。
具体命令操作如下：
```txt
git checkout -b some_feature develop   # 从develop分支创建某功能开发分支

# developing...then merge it to develp branch,before that,rebase pull first

git checkout develop  # 以下操作都在develop分支下进行
git pull     
git merge --no-ff some_feature  # 不使用fast-forward模式，保留合并信息
git branch -d some_feature   # 删除该短期分支
git push origin develop  # 推送到远程develop分支,这里默认本地develop分支追踪远程develop分支
```
develop分支合并到master分支过程基本相同，只不过记得打上标签tag,并使用命令`git push --tags`
来推送tag。

注： 如在develop分支上执行命令`git rebase master`将会导致develop分支上与master分支分离的
后续全部提交变成补丁(patch),git会逐个将这些补丁添加到现有的master分支上，从而使得master
分支与新的develop分支在一条直线上。`git pull`相当于`git fetch && git merge`,而`git pull 
--rebase`相当于`git fetch && git rebase`,像上文引用的那样，虽然这样保持了分支整洁，但是
在rebase的过程中容易出现问题，毕竟它改变了提交历史，风险很大，所以还是正常`git pull`为好。

### git submodule
带有submodule子模块的项目进行全部更新，根据`git pull --help`的说法，在已经checkout 
submodule的情况下，可以使用下面命令来一次性更新主项目和子模块：
> git pull --recurse-submodules

### git回退单个文件到指定版本
1. cd到文件父目录
2. git log filename
3. git reset commitId filename (对于文件名不能使用hard模式,默认mixed模式)
> git reset --soft  只回退commit信息，即head指针，index和worktree不变，可以用来压缩commit
> git reset --mixed 默认方式，回退commit和index,worktree不变，回退后需要checkout
> git reset --hard  commit,index,worktree都回退

4. git checkout filename
5. commit and push, done!

## Windows10 自带微软拼音输入法支持小鹤双拼输入法
本来还是用搜狗，但是虚拟机内无法联网登录，结果经常重启虚拟机后搜狗的设置全部都不见了，
非常麻烦，今天终于找到了让win10自带的拼音输入法支持小鹤的方法：
```txt
1. win + R，输入 regedit，打开注册表
2. 找到  计算机\HKEY_CURRENT_USER\Software\Microsoft\InputMethod\Settings\CHS 项
3. 新建一个名为 UserDefinedDoublePinyinScheme0 的字符串值，值为 小鹤双拼*2*^*iuvdjhcwfg^xmlnpbksqszxkrltvyovt
4. 打开控制面板--微软拼音输入法设置，把 小鹤双拼 设置为双拼的默认选择即可。
可以在区域中添加Enlish(United State),在高级键盘设置中设置英语为默认输入法，
同时勾选为每个窗口使用不同输入法，默认切换输入发快捷键为windows+space键。
```

## MacOS中vim添加中文输入法支持插件
linux下的fcitx.vim插件对于输入中文非常有效果，尤其是对于写这样的长篇中文博客来说，
有时切换中文输入非常麻烦，但是fcitx.vim是linux下的，mac不支持，今天又在网上搜到
有牛人写了个工具，可以迁移到macOS系统中来。简记如下：
```txt
vundle
Plugin 'CodeFalling/fcitx-vim-osx'

:PluginInstall

brew tap codefalling/fcitx-remote-for-osx
brew install codefalling/fcitx-remote-for-osx/fcitx-remote-for-osx --with-sogou-pinyin
Set your shortcut for Select next source in input menu to Ctrl-Shift-z
And set your English input method to US（美式英语）
```
OK！

## Karabiner针对某个app的快捷键设置
作为程序员快捷键必不可少，尤其是使用vim时，个人认为esc和capslock的位置必换不可。交换主要
还是通过各种改键程序来实现：
1. windows我用key tweak + hotkey, 可以交换键和快捷启动某些程序，
如F12启动cmder，windows+c启动cmd窗口一样。

2. linux ubantu下有gnome-tweak-tool或Xmomap文件等。

3. macOS有利器karabiner，而且有配套的keyEvent-viewer可以查看按下键的名字等，非常好用，
这次就是用它来针对某个特定的app进行设置快捷键。
背景：因为经常要用pdf阅读器查看技术书籍，需要经常在鼠标和键盘之间切换非常麻烦，ubantu下
自带的document viewer支持vim的操作，还有zathura也支持，说到底就是一个连续翻页的基础上
使用j向下滚动，k向上滚动的功能，在网上搜索到可以使用karabiner针对特定的app来定义快捷键。
```txt
vi ~/.config/karabiner/assets/complex_modifications/pdf-viewer.json
内容为（其中bundle_identifiers可以由keyEvent-viewer查看)
{
  "title": "keys",
  "rules": [
    {
      "description": "shortcuts for preview",
      "manipulators": [
        {
          "conditions": [
            {
              "bundle_identifiers": [
                "^com\\.apple\\.Preview$"
              ],
              "type": "frontmost_application_if"
            }
          ],
          "from": {
              "key_code": "k"
          },
          "to": [
            {
            "key_code": "up_arrow"
            }
          ],
          "type": "basic"
        },
        {
          "conditions": [
            {
              "bundle_identifiers": [
                "^com\\.apple\\.Preview$"
              ],
              "type": "frontmost_application_if"
            }
          ],
          "from": {
              "key_code": "j"
          },
          "to": [
            {
            "key_code": "down_arrow"
            }
          ],
          "type": "basic"
        }
      ]
    }
  ]
}


Got to karabiner preferences->complex Modifications->Add rule and press enable on it.
```

## 谷歌浏览器访问本地文件CORS错误

这个问题是由于本人有个静态网站目录存储在本地，直接访问index.html文件报错CORS.网上搜索到
解决方案如下。

1. 先关闭所有浏览器实例，从命令行启动谷歌浏览器:
`.\chrome.exe --allow-file-access-from-files`

2. 使用npm的http-server模块或python的SimpleHTTPServer模块,python3中该模块被整合进
http.server模块中，使用python3测试执行以下命令:
```txt
python --version   // 3.6.0
cd 到想要访问的files folder下，我这个路径下有个index.html文件
python -m SimpleHTTPServer  
谷歌浏览器访问http://localhost:8000或http://localhost:8000/index.html可以正常访问
```

## kindle, pocket, calibre, pandoc
昨天在网上看到QuQu的博客中有一个将自己的博客制作成电子书发到kindle上的效果，瞬间恢复了对
kindle的热情，这里简单记录下自己尝试的过程:
1. 使用pandoc将自己的博客markdown文件列表统一转换为一本epub电子书，这一步是使用haskell编写
的pandoc工具完成的，我写了一个脚本来获取博客中post文件夹下的所有md文件，统一拼接成一个字符串
作为pandoc命令的输入文件参数。
2. 生成epub后，由于亚马逊个人文档最大50M,邮箱附件最大20/30M的限制，所以我是用calibre转换
为azw3格式后直接用usb传到kindle中的。(也试过亚马逊官方的kindlegen, 也能生成，不过calibre
还支持从pdf转换到azw3, 功能更强大，所以就放弃了kindlegen, 统一使用calibre吧)。

将自己喜欢的网页保存下来制作成电子书。这个首先要说Pocket这个app, 有chrome插件，ios app, 
PC 多个平台，和印象笔记差不多，不过印象笔记免费用户限制较多。

pocket的Chrome插件的帐号设置界面中可以导出文章列表的html, 自己写一个脚本将其中的超链接的
href值提取出来，导入到oneTab中，全部打开后再用EpubPress统一转换为epub格式。
这样很麻烦，但对于零散的文章可以先在pocket中查看，进一步筛选后再做成电子书。
注: 可以简单的使用grep的正则表达式来提取url,命令如下:
`grep -Po "(?<=\")http(s)?://.*?(?=\")" ril_export.html > test.txt`

或者放入pocket中时就使用EpubPress做成电子书，再用calibre将所有零散的epub整合成一个大的epub.
calibre需要在偏好设置中安装新插件EpubMerge合并插件(还可以安装EpubSplit拆分插件)。

2019-08-30 10:51:13添加:
通过oneTab插件导入url,再通过EpubPress插件来生成epub电子书操作明显很麻烦，关键在于Epubpress
的网页内容抓取。所以我到它的github上查看其源码，希望能找到抓取的逻辑。

这时又发现EpubPress同时提供了EpubPress.js可以调用，并且ReadMe.md中介绍了使用方法，
所以我们就可以自己写个js使用node直接运行来生成需要的epub,而不再需要使用chrome插件。

EpubPress.js的抓取逻辑是先用node-fetch包的fetch方法抓取对应网站的全部内容，再用fileSaver.js
包保存的网页文件。

1. 安装EpubPress.js
`sudo npm install --save epub-press-js`

2. 写脚本调用EpubPress.js生成epub文件
这应该是写的第一个有用的node.js脚本了，node还是不错的，还可以调用shell命令。
node使用的是Chrome的V8引擎，FileSaver.js说它支持的chrome浏览器MaxBlog = 2GB, 如果理解的
没错的话，生成的epub最大也应该有2GB, EpubPress.js中没有看到其他限制，等以后pocket文章多了
以后看看是不是这个最大值。

可以加入koa, koa-route的node.js调试框架，测试node-fetch包的fetch方法运行结果。
调试node.js命令为`node --inspect test.js`.开发工具中点击node图标可以打开node.js的调试窗口。

getEpub.js代码如下:
```txt
const path = require('path');
var fs = require('fs');

// put pocket's html in blog directory, no need to contain in this blog
const data = fs.readFileSync(path.resolve(__dirname, '../ril_export.html'), 'utf-8');

console.log(data);
console.log('#####################################');
console.log('pocketFile read done!')
console.log('#####################################');
// 删除不匹配的内容，用正向否定环视定位，.*来具体匹配字符
const regexp = RegExp('(?<=")http(s)?://.*?(?=")', 'g');
let urlArr = [];
while((matches = regexp.exec(data)) != null){
  console.log(matches[0]);
  urlArr.push(matches[0]);
}

console.log('#####################################');
console.log('get url done!')
console.log('#####################################');

const EpubPress = require('epub-press-js');
const ebook = new EpubPress({
    title: 'Tao Pocket WebPages' + new Date().toLocaleDateString(),
    description: 'Personal favourite webpages',
    urls: urlArr 
});
ebook.publish().then(() => {
  // it will download to the current directory
    ebook.download();  // Default epub or ebook.email('epubpress@gmail.com')
}).then(() => {
   console.log('Success!');
}).catch((error) => {
    console.log(`Error: ${error}`);
}).then(() => {
  console.log('#####################################');
  console.log('epub done!');
  console.log('#####################################');
});
```
直接运行`node getEpub.js`命令，等待脚本执行结束后在当前目录可以看到生成的epub文件。

## Linux上安装jdk8, maven 
很神奇的是这么久在玩linux系统，但一直使用windows下的idea开发，主要还是因为认为快捷键是和
windows系统绑定的，最近想通了，完全可以将快捷键直接移植到Linux中。
1. IntelliJ 安装，这里略过。
2. 安装jdk8.
```txt
sudo apt install openjdk-8-jdk
sudo vi /etc/environment  # 添加以下环境变量
  JAVA_HOME="/usr/lib/jvm/java-8-openjdk-amd64"
```
3. 安装maven 3.6.1 这里我直接是使用.zip格式的安装包，直接解压即可
```txt
sudo vi /etc/environment  # 添加以下内容
  path变量最后添加 :/home/tao/wtt/apache-maven-3.6.1/bin 
  M2_HOME="/home/tao/wtt/apache-maven-3.6.1"

# update mvn commnad
sudo update-alternatives --install "/usr/bin/mvn" "mvn" "/opt/apache-maven-3.6.0/bin/mvn" 0
sudo update-alternatives --set mvn /opt/apache-maven-3.6.0/bin/mvn

# mvn commnad autoComplete
sudo wget https://raw.github.com/dimaj/maven-bash-completion/master/bash_completion.bash --output-document /etc/bash_completion.d/mvn

# logout and login
mvn --version

# 修改settings.xml文件 添加阿里云镜像仓库
<mirrors>
  <mirror>  
       <id>alimaven</id>  
       <name>aliyun maven</name>  
       <url>http://maven.aliyun.com/nexus/content/groups/public/</url>  
       <mirrorOf>central</mirrorOf>          
   </mirror>
 </mirrors>
```

## 关于pip的2个问题
1. pip install报错
```txt
File "/usr/bin/pip",line 9, in <module>
  from pip import main
Import error: cannot import name main
```
解决: 这是pip 10和pip 8冲突导致，卸载pip 10即可，ubantu上应尽量使用apt.
`python -m pip uninstall pip`

2. pip uninstall 不会删除相关的依赖包
```txt
pip install pip-autoremove 
# 如删除batmon的相关依赖
/home/tao/.local/lib/python2.7/site-packages/pip_autoremove.py batmon -y
```

## 使用shell脚本来重启sprintboot应用
通过查资料和以前的一些印象终于搞出个能用的......
```txt
#!/bin/bash

export SPRING_PROFILE=prod
export APP_NAME=pra-plat
export VERSION=1.0.0-SNAPSHOT
export SERVER_PORT=8080

## setting log home
export JAR_HOME=/home/ap/cloudapp
export LOG_HOME=/home/ap/cloudapp/logs
export LOG_NAME=${APP_NAME}


# =两边不能有空格,命令输出结果用$()来赋给变量,注意awk的写法
pid=$(ps -ef | grep java | grep ${APP_NAME}| awk '{print $2}')
# 注意如何判断变量为空
if [ ${pid} ]
then # then需要另起一行，与if在同一行时需要在then前加分号
    echo "stop ${APP_NAME}_${SERVER_PORT} service"
    echo "kill process ${pid}"
    kill -9 ${pid}
fi

echo "start ${APP_NAME}_${SERVER_PORT} service"
JAVA_OPTS="-Dspring.profiles.active=${SPRING_PROFILE}"
# 直接jar包报cannot access jar file错误
nohup java -jar ${JAVA_OPTS} ${JAR_HOME}/${APP_NAME}-${VERSION}.jar >${LOG_HOME}/${LOG_NAME}.out 2>&1 &

echo "tail -f ${LOG_HOME}/${LOG_NAME}.out"
```

## Mac parallel安装centos虚拟机
1. 下载centos最小安装镜像,我选择的版本是CentOS-7-x86_64-Minimal-1810.iso
官网地址: [centos下载](https://www.centos.org/download/)

2. 一步步安装，登录后发现命令界面太小，网上搜索后没有解决办法，突然想到可以用远程ssh
登录，自己装的iterm2已经非常美观实用了。
已找到方法：[修改centos分辨率](https://superuser.com/questions/816528/with-centos-7-as-a-virtualbox-guest-on-a-mac-host-how-can-i-change-the-screen-r)
```txt
$ sudo su
$ vi /etc/default/grub 
add vga=792 to the end of GRUB_CMDLINE_LINUX
$ grub2-mkconfig -o /boot/grub2/grub.cfg
$ reboot
```

3. centos开通root远程ssh访问权限
```txt
$ ssh -V    # 查看ssh 版本
$ vi /etc/ssh/sshd_config 
将配置中的 #PermitRootLogin yes 这一行前面的＃号去掉
$ service sshd restart  # 重启ssh服务
$ ip addr   # 查看ip地址，eth0中的inet值即是

本地mac iterm2 登录ssh
$ ssh -l tao 10.211.55.9
输入密码链接成功！
```
4. centos关机命令
`sudo shutdown 0`

5. iterm2配置自动登录ssh
网上说的是配置profile,但启动还需要定义快捷键，可以直接定义别名

6. 用item2登录后发现centos界面颜色与真实的一致，所以还是需要修改centos上自带的颜色
```txt
$ cp /etc/DIR_COLORS ~/.dir_colors
vim ~/.dir_colors
第59行：DIR 01;34（01：粗体，34：蓝色）
修改为：DIR 01;33（01：粗体，33：黄色）
```
## 老mac安装Ubantu
昨天在新mac上用parallel成功安装了centos虚拟机，想到我那个小的mid-2011的macbook air,
突然萌生了要改装linux系统的想法，马上google搜索一番，发现果然有人在网上说可以这样干，
因为老mac带不动最新的macOs系统，却可以带动最新的linux系统，但linux系统版本众多，选择
哪一个版本也是问题，google上有人测评过，说还是ubantu靠谱,所以就决定装它了!
具体安装过程参考这篇文章：
[try out linux on aging mac](https://www.imore.com/how-try-out-linux-aging-mac)

具体安装过程就按这篇文章进行即可，找个u盘用软件Ether做成系统光盘，然后在老mac上启动时
按option键选择install ubantu即可。
安装过程中可以先不连wifi，语言可以选英文，选中文的话会出现中文目录。

ubantu下载软件比较慢，可以换成阿里云的源，不同版本的ubantu源也不一样，
我装的是最新的LTS版18.04。
   1. 备份原来的源文件
   sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak
   2. 安装vim
   sudo apt-get install vim
   3. 编辑源文件
   sudo vim /etc/apt/sources.list
   4. 可以全部删除原来的，新增以下内容
```txt
deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse
```
  
   5. 更新软件列表
    sudo apt-get update
   6. 更新软件包
   sudo apt-get upgrade

   7. 其中系统的复制粘贴命令同windows，ctrl+c,ctrl+v。终端(ctrl + option + t)中的复制粘贴
   可以从preference中看出，复制ctrl+shift+c,粘贴ctrl+shift+v.

   8. 安装蓝灯，github上有ubantu版

   9. 安装google浏览器。
      1. 在ubantu中访问[google官网](https://www.google.com/chrome/),
   点击下载会自动出现linux版，下载到Downloads下面。
      2. 终端中执行：
      > dpkg -i google-chrome-stable_current_amd64.deb

      3. 网上说可能报错，需要按提示的命令执行apt-get -f install,我这边没有报错，直接按
      command键输入google，愉快的打开并登陆了！
   10. 使用vim经常要用到esc键，所以我习惯将capslock与esc键交换位置
   tweak-tool的工具。
   > sudo apt-get install gnome-tweak-tool -y && gnome-tweak-tool

   装好后有一个tweaks应用，在keyboard&Mouse>additional layout>capslock behavior>
   swap esc and capslock

   11. 完全卸载ubantu里的软件
```txt
apt-get purge / apt-get --purge remove 
删除已安装包（不保留配置文件)。如软件包a，依赖软件包b，则执行该命令会删除a，
而且不保留配置文件

apt-get autoremove 
删除为了满足依赖而安装的，但现在不再需要的软件包（包括已安装包），保留配置文件。

apt-get remove 
删除已安装的软件包（保留配置文件），不会删除依赖软件包，且保留配置文件。

apt-get autoclean 
APT的底层包是dpkg, 而dpkg 安装Package时, 会将 *.deb 放在 /var/cache/apt/archives/中，
apt-get autoclean 只会删除 /var/cache/apt/archives/ 已经过期的deb。

apt-get clean 
使用 apt-get clean 会将 /var/cache/apt/archives/ 的 所有 deb 删掉，可以理解为 
rm /var/cache/apt/archives/*.deb。

实际使用：
# 删除软件及其配置文件
apt-get --purge remove <package>
# 删除没用的依赖包
apt-get autoremove <package>
```

   12. gnome用上面的gnome-tweak-tool软件可以成功，但后面又看到阮一峰推荐的fish+Xfce+
   xmonad+vim的工作套件，尤其是xmonad窗口管理工具简直是分屏利器，于是把我的老mac也整
   这样一套。
     1. ubantu上安装xfce桌面，登录时可以选择桌面系统，ubantu(gnome)或xfce(更轻更快)
     > sudo apt install xfce4  #xfce最新的为2015年的4.2版本

     2. 交换xfce中的esc和capslock键，新建文件~/.Xmodmap,其中内容为
```txt
clear Lock
keysym Caps_Lock = Escape
keysym Escape = Caps_Lock
add Lock = Caps_Lock
```
    3. 重启后修改也生效！蓝灯和google浏览器也能访问之前安装的程序。
    注：xfce下之前测了可以，但在ubantu默认的gnome3下该交换重启后又不行了，gnome3下重启后
    仍生效的是执行下面这个命令，使用gnome3默认安装的dconf工具：
    > dconf write "/org/gnome/desktop/input-sources/xkb-options" "['caps:swapescape']"

2019-09-05 14:41:45 添加:
xfce中一直使用上面的xmodmap配置文件来交换esc和capslock键，但最近总失灵，
需要重新执行xmodmap文件，并且开启新的窗口报错。
在网上又找到个方案，目前看可以使用，没有报错，步骤记录如下:
```txt
1. 删除上面的.XmodMap文件，不然无效
2. vi /usr/share/X11/xkb/rules/base.lst
3. 搜索esc, 找到交换capslock和esc的配置项`caps:swapescape`.
4. sudo vi /etc/default/keyboard 
5. 修改为XKBOPTIONS="caps:swapescape"
6. sudo dpkg-reconfigure keyboard-configuration
7. 我选择了general 104 key and us layout, 最后确定保留配置
8. 重启电脑生效
```
另外linux下的pdf编辑工具，使用libreOffice Draw进行编辑，可以下载pdfshuffler来进行删除和
合并pdf操作。经测试重组的pdf仍然会有些小问题，还是可以看，有问题再对照原版吧。

    4. 安装fish shell.
    > sudo apt-get install fish
    > fish  #启动shell,不建议设置为默认shell

    5. 安装xmonad
    > sudo apt-get install xmonad
    > sudo apt-get install xmobar dmenu  #小工具

    安装完之后只logout发现没有xmonad桌面，重启后才出来那个全黑的界面，果断alt+shift+enter,
    当当！终端出来了，vim看看capslock和esc也已经交换了，证明了它确实只是一个窗口管理软件，
    至此，fish+xfce+xmonad+vim的一套已经搞定，具体使用和问题后面再写，今天到点睡觉了！
    -- 2019-03-31 23:00:21 

    xmonad下蓝灯无效果，而且中文输入法也出不来，只能暂时放弃，等以后有需求和时间再来折腾
    一下。


   13. 安装fcitx来使用小鹤双拼，以及vim中输入中文输入的插件
```txt
sudo apt install fcitx
sudo apt install fcitx-pinyin
fcitx
在桌面图标上选择config current input method
为配合插件使用，第一位选择keyboard-English,第一个加上Shuangpin,
这里加上以后默认的不是小鹤双拼，需要修改默认双拼方案
cd ~/.config/fcitx/conf
vi fcitx-pinyin.config
设置为DefaultShuangpinSchema=XiaoHe
```
另: fcitx输入中文变繁体，按ctrl + shift + f变回简体输出。

   14. 在ubantu系统启动时执行某些命令，如`sudo tlp start`软件减少散热的，还有命令别名
   设置等，之前放到.bash_profile中不行，网上搜索到可以放在.bashrc中，查看.bashrc文件，发现
   它有检查.bash_aliases文件，于是新建该文件，将命令放入其中即可。

   15. shell基本使用

      1. 不建议设置为默认shell,在.bashrc或.bash_aliases中写入`exec fish`来实现启动终端时执行
   fish。
      2. 执行命令`fish_config`进入网页配置界面，默认8000端口打开的本地网页，可以设置颜色
      主题和提示符prompt等。
      3. 自定义别名
      ```txt
 alias post 'cd /home/tao/wtt/blog/source/_posts'
 funcsave post     #可以在.config/fish/config.fish/functions下找到生成的fish文件
 alias pull 'git pull; and echo "done"'
 funcsave pull
 alias push 'git add . ;and git commit -m $argv[1];and git push origin source; and echo "done"'
 funcsave push
 alias pub 'git push github source;and echo "done"'
 funcsave pub
      ```
  2019-08-16 15:41:06 添加:
Linux下使用sdcv作为终端查单词非常方便，直接使用sudo apt install sdcv即可安装，其中词典
需要自己下载，google一个星际译王的网站，里面有大量词典。其中有些字典在终端下排版格式不
好看，无法阅读，只能放弃。
目前本人使用的字典有(排序分先后):
Collins Thesaurus (En-En)
Concise Oxford English Dictionary (En-En)
Oxford Advanced Learner's Dictionary 8th Ed.
Cambridge Advanced Learners Dictionary 3th Ed. (En-En)

通过man sdcv查看相关命令配置等。fish的别名使用上面的alias命令无法生效，报错找不到文件，直接
写function然后保存反倒是成功了，说明了function的适用性更强一点。

 2019-08-21 09:38:15 添加:
在写博客的过程中如果要使用命令行查单词，需要先退出vim编辑器，比较麻烦，可以使用linux
命令ctrl+z将当前任务暂时挂起并停止运行，查询完单词后使用fg命令将挂起命令恢复到前台。

   16. vim中输入中文的插件，实现插入模式中自动切换为中文，leave insertMode时切换为英文，
   按教程安装vundle,plugin有
  ```txt
Plugin 'scrooloose/nerdtree'
Plugin 'lilydjwg/fcitx.vim'
  ```
  fcitx.vim针对的是fcitx下的中文输入，其脚本中也是切换键盘输入，所以前面设置fcitx时需要
  将第一位设置为英文，第二位设置为双拼。其插件脚本为
```txt
"##### auto fcitx  ###########
let g:input_toggle = 1
function! Fcitx2en()
   let s:input_status = system("fcitx-remote")
   if s:input_status == 2
      let g:input_toggle = 1
      let l:a = system("fcitx-remote -c")
   endif
endfunction

function! Fcitx2zh()
   let s:input_status = system("fcitx-remote")
   if s:input_status != 2 && g:input_toggle == 1
      let l:a = system("fcitx-remote -o")
      let g:input_toggle = 0
   endif
endfunction

set ttimeoutlen=150
"退出插入模式
autocmd InsertLeave * call Fcitx2en()
"进入插入模式
autocmd InsertEnter * call Fcitx2zh()
"##### auto fcitx end ######
```

## ubantu下vim的粘贴复制问题
昨天使用ubantu默认的gnome-teminal时，发现多个tab间无法进行复制粘贴操作，经网上搜索发现
以前gnome-terminal确实有这个bug,但是后来已经修复了，回到家用自己电脑下了一个terminator
来替代gnome-terminal，发现还是有这个问题。本来已经放弃了，但是今天无意中搜索到原来是vim的
问题，原生的vim不能与系统剪切板进行交互，需要下载vim-gnome！
```txt
sudo apt --purge remove vim
sudo apt install vim-gnome
```

OK!将原来的.vimrc中
```txt
#set clipboard+=unnamed
noremap <Leader>y "+y
noremap <Leader>v "+p
noremap <Leader>V "+P
```

## ubantu下vmware虚拟机网络设置问题
终于这个困扰本人许久的问题终于正式解决了！
首先看一下引发解决的关键点：
1. vmware workstation的editor->virtual network editor
2. bridge,nat,host等概念
3. 有限网络的默认网关屏蔽

首先介绍一下操作背景，银行通过有线网线来链接内网，平时查资料需要通过个人热点来链接外网，
同时因本人喜欢终端命令行操作及vim编辑等功能，打算放弃windows操作系统，但银行内部需要
windows来进行工作，所以是重装了ThinkPad T540P笔记本为ubantu LTS 18.04系统，安装了
linux版的vmware workstation,其中安装了用于工作的windows10系统————这就是操作环境。

1. 插上网线和链接上个人热点后，通过`ip route show`看到有两个默认网关，链接外网失败。
在网络设置中-wired connected-settings-ipv4中，先关闭链接，再勾选
use this connection only for resources on its network
再链接后，可以发现默认网关只有一个热点了，此时可以上外网。

2. 配置vmware workstation的网络设置，在editor->virtual network editor中进行配置，可以
选择对应的网卡。
```txt
Bridge mode:This connects the virtual network adapter directly to the physical network
NAT: This allows the virtual network adapter to share the host’s IP address
Host Only: This creates a private network that the virtual network adapter shares with the host
Custom: This allows you to create your own virtual network

Note: Although VMnet0, VMnet1 and VMnet8 are technically available in this menu, 
they are usually used for bridged, host-only, and NAT configurations, respectively.
```
由以上概念可知，这里实际需要的就只是桥接模式，直接接入物理网络，nat模式选择时还需要进行
手动网络转换，而且之前使用也达不到目地，就不选这个了，host模式只能宿主机访问，也不满足要求。
这里为避开0,1,8的默认名字，可以取名VMnet11,12代表有线和无线2个网卡。

3. 为工作的虚拟机配置里选择网络设置为custom，选择刚才新建的虚拟有限网卡，为自己玩的
centos配置虚拟无线网卡。

4. 登录工作虚拟机，发现链接内网成功！

5. 登录centos7,这里时新建的minimal安装，执行以下命令：
```txt
cd /etc/sysconfig/network-scripts/
ip addr // 查看除了lo外的另一个网卡名字如ens33
su root  // enter password
vi ifcfg-ens33
onboot=no 改为 yes
systemctl restart network
ping www.baidu.com   // done!
```

## ubantu修改swap文件
```txt
sudo swapoff /swapfile
sudo rm -rf /swapfile
sudo dd if=/dev/zero of=/swapfile bs=1024 count=2000000  #建立swap文件2G
sudo chmod 600 /swapfile     
sudo mkswap /swapfile    #创建系统
sudo swapon /swapfile   # 开启swap
sudo vi /etc/fstab
/swapfile swap swap defaults 0 0
free -h  # check swap size
```
## ubantu备份和还原
终于完美从thinkpad迁移到mac的虚拟机上！
1. 备份老系统
由于我是默认用的fish,所以为防止报错，写了一个bash shell脚本来执行打包命令
```txt
vi bashShell.sh

内容如下
#!/bin/bash
tar cvpzf /media/tao/ExFAT/backup.tgz --exclude=/media/* --exclude=/sys/* 
--exclude=/proc/* --exclude=/dev/* --exclude=/run/* --exclude=/snap/* 
--exclude=/home/tao/vmware/* 
--exclude=/home/tao/Documents/CentOS-7-x86_64-DVD-1804.iso /

sudo su
chmod +x bashShell.sh
sudo ./bashShell.sh
```

2.如果是原来机子回复系统，可以这样做（未测试）
```txt
cd /
sudo su
sudo tar -xvpzf /media/tao/ExFAT/backup.tgz -C /
sudo reboot 0
```
done!
注： tar命令只会覆盖已有的文件，备份后新增的文件不会修改或删除。

3.如果是虚拟机或其他电脑，因为硬盘的uuid不同，所以需要多些步骤
由于我的移动硬盘是exfat格式，所以需要给ubantu安装exfat-utils:
```txt
更新数据源为阿里云，
sudo apt update
sudo apt install exfat-utils
插上u盘后，始终无法识别，这里还要将vmware虚拟机设置下硬件，
改为usb 3.0接口

备份fstab,得到其中的uuid
cd ~
mkdir back
cd /etc/
sudo cp fsta ~/back
备份grub.cfg
sudo cp /boot/grub/grub.cfg ~/back

恢复旧系统备份
cd /
sudo su
sudo tar -xvpzf /media/tao/ExFAT/backup.tgz -C /

回复fstab和grub
sudo cp ~/back/fstab /etc/
sudo cp ~/back/grub.cfg /boot/grub/

重启
sudo reboot 0
```
done!
 
4. 卸载ubantu虚拟机上的vmware-workstation软件
sudo ./VMware-Workstation-Full-15.0.3-12422535.x86_64.bundle -u vmware-workstation

## vmware workstation上修改ubantu分辨率
27寸的HKC屏幕最佳分辨率是2560X1440,ubantu虚拟机给出的最大分辨率是2560X1600,网上找到可以
修改的方案，记录如下：
```txt
xrandr   # 得到第二行的第一个单词，connected primary前的单词为显示设备名称Virtual1

cvt 2560 1440   # 输入需要的分辨率
# 得到一行modeline
# Modeline "2560x1440_60.00"  312.25  2560 2752 3024 3488  1440 1443 1448 1493 -hsync +vsync

# 添加新mode, --newmode后为前面的modeline
sudo xrandr --newmode "2560x1440_60.00"  312.25  2560 2752 3024 3488  1440 1443 1448 1493 -hsync +vsync

# 将新模式应用到显示设备中,设备名和分辨率分别取前面的值
sudo xrandr --addmode Virtual1 "2560x1440_60.00"

# 在settings->resolution中可以看到需要的分辨率了，apply即可成功！

# 编辑～/.profile使ubantu下次以这个分辨率启动
加入上面2行命令
sudo xrandr --newmode "2560x1440_60.00"  312.25  2560 2752 3024 3488  1440 1443 1448 1493 -hsync +vsync
sudo xrandr --addmode Virtual1 "2560x1440_60.00"
```
注！按以上配置，重新登录后黑屏，只好在登录界面按ctrl+alt+F3进入命令登录界面，
删除刚才修改的~/.profile文件。
具体原因明天再看吧！

## xmonad
折腾了一晚上，成功的搞出了背景图片，浏览器里可以输入中文(fcitx),双屏切换alt+w,r操作前先
在大屏上最大化再扩展小屏也能正常使用，但是！vim里面fcitx又出不来了，终于放弃，后来又发现
ubantu gnome也支持双屏操作的快捷键，主要是以下4个快捷键
```txt
alt + tab  切换应用
alt + esc(我改成capslock)  切换上下屏幕
command + shift + up/down  将当前窗口移动到上面的屏幕或下面的屏幕中
```
就这样吧，太喜欢折腾也不好，还是不能为了工具太折腾，明天赶紧装下idea, 正常写代码和锻炼！

 2019-04-21 22:01:59
 注: 说不折腾，但还是又搞了几天，终于搞出来了，也算行吧。
 ubantu上直接安装xmonad，按教程走到最后，发现在终端里始终不能输入中文，但浏览器里可以，
这个问题卡了蛮久，当时想的是终端的问题，但没有实践，后来又转到mac下去实现xmonad了，不过
最近又实践了一下，发现成功了！mac也成功了！双喜临门！记录如下：

1. ubantu 18.04下安装xmonad
主要是参照教程[https://beginners-guide-to-xmonad.readthedocs.io/intro.html](https://beginners-guide-to-xmonad.readthedocs.io/intro.html),
我自己修改的地方就是改动了最后的启动文件.xsessionrc

```txt
#!/bin/bash

# Load resources

xrdb -merge .Xresources

# Set up an icon tray
stalonetray &

# Fire up apps

xscreensaver -no-splash &

if [ -x /usr/bin/nm-applet ] ; then
   nm-applet --sm-disable &
fi

fcitx &
xmodmap ~/.Xmodmap &
feh --bg-scale ~/back.jpg &
# 虚拟机内使用 vmware-tool
vmware-user &

export GTK_IM_MODULE=fcitx
export QT_IM_MODULE=fcitx
export XMODIFIERS=@im=fcitx

exec xmonad
```
可以看到我加了输入法fcitx,esc和capslock键的交换，背景图片以及fcitx的环境变量配置
其中.Xmodmap文件内容上文有提到，这里掠过。

最后，替换掉gnome-terminal发现可以正常使用fcitx输入法，
sudo apt install terminator
sudo update-alternatives --config x-terminal-emulator
选择terminator，输入其编号即可

Done!
xmonad官网上有与gnome整合的文章，没有细看，这里配好了就不需要它了，
[https://xmonad.org/documentation.html](https://xmonad.org/documentation.html)
最下面一排小字！
ubantu上还有问题就是vmware-tool的复制粘贴功能没有了，gnome下可以实现，还需要再整整，
to be continued......

 2019-04-22 21:14:57 solved:
 google上搜到了vmware-tools-user-guide官方文档，可以手动启动vmware user process进程，
 在.xsessionrc中加入一行： `vmware-user &`
 Done!
 另：上班时发现电脑自动关机了，后来发现是电池没有电了，xmonad没有低电量警告！
 网上搜到一个python程序rcoh/batmon

```txt
sudo apt install python-pip
pip install batmon
ls /sys/class/power_supply/   #BAT0或其他数字
vi ~/.xsessionrc # 添加
batmon BAT0 &
```

 2019-04-23 21:46:57 注：
 在thinkpad上使用了无效果，发现notify-send命令在xmonad下无效,


当时也是在那发现了
mac上安装xmonad的方法，根据这个又整了一个周末。 
[https://wiki.haskell.org/Xmonad/Using_xmonad_on_Apple_OSX](https://wiki.haskell.org/Xmonad/Using_xmonad_on_Apple_OSX)
这篇太简略了，还参照了这篇[my xmonad recipe for macOS](https://gist.github.com/danchoi/3923233)

我自己的步骤为
1. 下载XQuartz,并按recipe里设置好
2. 下载haskell-platform macOS 64位安装包(brew安装太慢，问题太多了...)
3. 在文章里找到这个[https://github.com/xmonad/X11/issues/24](https://github.com/xmonad/X11/issues/24),使用命令
LIBRARY_PATH=/opt/X11/lib:$LIBRARY_PATH cabal install xmonad
4. 按wiki.haskell里新建~/.xinitrc/90-xmonad.shell，但xmonad并没有生效，USERVM中的路径用
命令`which xmonad`并没有输出，也搜索了很久和重装xmonad后，在~/.cabal/config中发现说要在
.bash_profile中加入path变量，加入后，`which xmonad`即成功输出为文档中的值。
5. 启动XQuartz,设置成全屏模式，并按alt+shift+enter,可以发现xmonad成功启动了！
但它还不支持多屏...
to be continued
 2019-04-22 22:55:55 注：
 今天又试了下，发现XQuartz在全屏模式下是支持多屏的，用xmonad的mod+w,e可以正常切换屏幕，
 明天再试着调用app,改造终端样式等。
 2019-04-23 21:44:56
 看到一篇日语文章，和我之前整的过程差不多，它最后也是推荐Amethyst,想想mac上xmonad也就整到
 这里了。

 2019-04-26 18:39:10
 今天解决了2个在实际使用ubantu,xmonad,lantern的问题
 1. xmonad下无电池低电量预警
 xmonad-contrib里之前收到有一个urgency插件，但配置比较麻烦，也许可以使得notify-send命令
 产生效果，但一直没试。今天搜到可以让有电池信息的xmobar在xmonad全屏模式下显示出来，具体
 是修改.xmobarrc文件
```txt
Config { font = "-*-Fixed-Bold-R-Normal-*-13-*-*-*-*-*-*-*"
        , borderColor = "black"
        , border = TopB
        , bgColor = "black"
        , fgColor = "grey"
        , position = TopW L 100
        , persistent = True     # wtt-add
        , overrideRedirect = False  # wtt-add
        , commands = [ Run Weather "ZUUU" ["-t","<tempC>C","-L","18","-H","25","--normal","green","--high","red","--low","lightblue"] 36000
        , Run Battery [ "--template" , "Batt: <acstatus>"
               , "--Low"      , "10"        -- units: %
               , "--High"     , "80"        -- units: %
               , "--low"      , "darkred"
               , "--normal"   , "darkorange"
               , "--high"     , "darkgreen"
               , "--" -- battery specific options
                      -- discharging status
               , "-o"	, "<left>% (<timeleft>)"
                      -- AC "on" status
               , "-O"	, "<fc=#dAA520>Charging</fc>"
                      -- charged status
               , "-i"	, "<fc=#006000>Charged</fc>"
             ] 50
                        , Run Network "eth0" ["-L","0","-H","32","--normal","green","--high","red"] 10
                        , Run Network "eth1" ["-L","0","-H","32","--normal","green","--high","red"] 10
                        , Run Cpu ["-L","3","-H","50","--normal","green","--high","red"] 10
                        , Run Memory ["-t","Mem: <usedratio>%"] 10
                        , Run Swap [] 10
                        , Run Com "uname" ["-s","-r"] "" 36000
                        , Run Date "%a %b %_d %Y %H:%M:%S" "date" 10
                        , Run StdinReader
                        ]
        , sepChar = "%"
        , alignSep = "}{"
        , template = "%StdinReader% | %cpu% | %memory% * %swap% | %eth0% - %eth1% | %ZUUU% | %battery% }{<fc=#ee9a00>%date%</fc>  | %uname% "
        }
```
这样配了之后，打开需要的google,vmware,terminal，需要重启xmonad才能看到xmobar，目前只能这样
了:执行命令`xmonad --restart`。

2. xmonad和KDE,XFCE下lantern可链接但无法访问google问题，此前只有在gnome下lantern才能正常
使用。今天搜索如何在linux下设置代理找到了配置方法，成功在xmonad下正常使用xmonad。
```txt
sudo vi /etc/environment

添加
all_proxy=socks://127.0.0.1:43359/
ALL_PROXY=socks://127.0.0.1:43359/
http_proxy=http://127.0.0.1:43359
HTTP_PROXY=http://127.0.0.1:43359
ftp_proxy=http://127.0.0.1:43359
FTP_PROXY=http://127.0.0.1:43359
https_proxy=http://127.0.0.1:43359
HTTPS_PROXY=http://127.0.0.1:43359

新建配置文件，这个应该是针对apt的代理设置
vi /etc/apt/apt.conf 

Acquire::http::proxy "http://127.0.0.1:43359/";
Acquire::ftp::proxy "ftp://127.0.0.1:43359/";
Acquire::https::proxy "https://127.0.0.1:43359/";
使用命令来校验
apt-config dump  | grep -i proxy
```

之前突然看到有linux上的fliqlo屏保，叫gluqlo,今天在xmonad上成功安装。
1. 因为之前装xmonad时已经安装了xscreensave,所以把另外2个包也下载下，主要是各种屏保文件。
sudo apt remove gnome-screensaver # 这步没有执行
sudo apt install xscreensaver-gl-extra xscreensaver-data-extra

下载gluqlo
sudo apt-add-repository ppa:alexanderk23/ppa
sudo apt-get update
sudo apt-get install gluqlo

看了xscreensaver manual,里面说设置直接执行以下命令即可
xscreensaver-demo
里面选择只展示一张，选中gluqlo即可。
主动激活屏保的命令
```txt
sleep 2; xscreensaver-command -activate
```
结合前面的重启xmonad命令，可以这样定义2个别名
```txt
alias rstX 'xmonad --restart'
funcsave resX
alias xlock 'sleep 1; xscreensaver-command -activate'
funcsave xlock
```

## xfce中使用vmware-workstation快捷键问题
由于xmonad没有很方便的提示电池电量的方法（不支持notify-send命令）,所以在经历了几次电池
耗尽自动关机后还是抛弃了xmonad,转向xfce,xfce也没有自带电池监控软件，但是可以
`sudo apt install xfce4-battery-plugin`插件，实际使用很方便，到设定的百分比时在虚拟机
全屏界面下也可以正常给出弹框提示。
 2019-08-22 16:19:45 添加:
xfce4桌面不能调节屏幕亮度，网上搜索到可以安装`sudo apt install xfce4-power-manager-plugins`,
可以实现鼠标拖动修改屏幕亮度，还有电池电量监控，所以可以不用安装上面的battery插件。

在实际使用虚拟机时发现一个快捷键问题，在ctrl+alt跳出虚拟机后，在不知情的情况下按下Idea
的快捷键ctrl+e来查看最近打开的文件，结果虚拟机关闭了！！！

原来vmware-workstation自带的快捷键有
ctrl + e  power off
ctrl + r  reset power 

主要是这2个大坑，其他快捷键没有多大影响。经网上搜索windows下可以用autohotkey来映射ctrl+e
到别的键上，mac可以用karabiner,linux可以用xmodmap,但具体xmodmap怎么配置组合按键没有搜到，
但对于xfce可以使用其自带的快捷键修改功能来完成。
终端下输入
`xfce4-settings-editor`进入键盘修改界面，
```txt
xfce4-keyboard-shortcuts -> commands/custom
-> new ->
property: /commands/custom/<Control>E
type: String
value: gedit或terminator等任意其他即可
-> close
Done!

同理可设置ctrl+r
```
 2019-05-10 11:27:34 注:
 实际使用时发现ctrl+r在vim中是默认的redo,按以上设置无法正常使用，所以保险的方法还是
 在跳转到虚拟机界面时按j或k,使用虚拟机的capture key功能来避免误操作。
 ctrl+e的设置可以保留。

## xfce4 截屏
需要安装截屏插件
`sudo apt install xfce4-screenshooter`
在applications->settings->keyboard->application shortcut中add
command:
xfce4-screenshooter -r
按键prt-sc定义快捷键，done!

## ubantu内核升级后回退版本
最近在系统中安装了sdcv方便查找单词，不自觉的按网上常规"要求"执行`sudo apt update`命令后
在乖乖执行`sudo apt upgrade`进行系统升级操作。结果上班发现vmware-workstation启动不起来，
报错`cannot build vmnet`, 经过多番尝试，发现可以回退内核版本，回退就可以正常工作了，所以
没事还是不能随便升级!尤其是在工作电脑上！

回退步骤:
1. 修改/etc/default/grub文件，将其中的`grub_timeout`值修改为3以上的数字。
2. 重启时按esc(EFI固件)进入grub页面，选择ubantu高级操作，选择需要回退的内核版本(不要选择
有其他后缀的版本，如rollback等)。
3. done!

## command line editor in fish shell
1. 发现可以用ssh远程登录自己的ubantu虚拟机来写博客，如果要在本地的mac上使用ubantu上的
zathura看pdf的话，还需要在mac上配置X11forwarding=yes, 并且启动Xquartz, 折腾了一下，mac
终端卡住没反应。想想还是觉得没必要，mac也有zathura的brew版本，不过毕竟zathura原本是linux
上的软件，移植过来性能或配置可能会有些问题(看其github的issue等), 还是用虚拟机本体看pdf吧。

2. mac的终端有些命令如ls和linux终端还是不一样的，还是不同流派的原因，所以也没有必要非要将
mac都改造成linux的功能, 如使用命令`brew install coreutils`等。我还是就使用虚拟机玩ubantu, 
RHEL等原生linux系统吧。

3. 在网上突然发现命令行上也可以使用vim，虽然之前在银行的服务器上看到过这样的效果，但以为
那是它自带的效果，今天发现原来它是命令行绑定的键盘映射。我们平时经常用的是默认的Emac模式，
如ctrl + a, ctrl + e跳到开始和结束位置等快捷键都是Emac的快捷键。因为我使用的shell是fish,
所以它修改为vim的命令行编辑器的命令为
```txt
# 切换为vim模式 -U universal 重启Shell后也生效
set -U fish_key_bindings fish_vi_key_bindings 

# 切换为默认的Emac模式
set -U fish_key_bindings fish_default_key_bindings  
```
vim模式在命令提示符前会给出当前模式的提示符，但是fish的自动补全功能快捷键ctrl+f在vim模式中
无法使用了。fish的github的issue中讨论了这个问题，说可以单独指定，但这样很可能vi的模式提示
符就没有了(fish document中还给出了一个`hybrid_bindings`方案，经测试可以使用，功能很强大，
可以同时使用Emacs和vim的快捷键，但还是没有模式提示), 经测试比较，还是决定直接使用vim模式，
需要补全的，按Esc跳到普通模式后使用w进行补全操作，也不是很麻烦.

## SSH to Vmware Fusion ubantu guest from mac 
1. ubantu上要安装ssh-server, 关闭防火墙。
2. 查看ip addr show查看ip地址, 之前用ip route show查看的default不是它的IP地址，下面的ens33
网卡的IP才是真实IP, 因为IP搞错了，搞得一晚上连不上也是无语了。
3. 确认是桥接模式的网卡适配器。
4. mac上直接使用`ssh tao@xxx.xxx.xx.xx`进行连接，输入密码后即可登录。

注: 可以将本地mac的SSH公钥传输到VM guest上，这样下次登录就不用输入密码了，命令为
`ssh-copy-id tao@xxx.xxx.xx.xx`.

再注: 使用mac SSH登录到虚拟机上时发现fcitx-vim的输入法切换插件无法使用了，估计它还是需要底层
的输入法控制，fcitx-vim插件作者在博客中有提到在不同linux主机间的ssh操作可以使用socat转发
套接字，不过mac就不行了。最后发现我之前的小工具博客中有记录具体的fcitx-vim-for-osx的操作
过程，配置成功！

## Xmonad Latest and Fullest config
.xmonad/xmonad.hs
```txt
import XMonad
import XMonad.Hooks.DynamicLog
import XMonad.Hooks.ManageDocks
import XMonad.Util.Run(spawnPipe)
import XMonad.Util.EZConfig(additionalKeys)
import System.IO
import XMonad.Actions.CycleWS
import XMonad.Actions.DwmPromote
import XMonad.Hooks.ManageHelpers
import XMonad.Layout.Fullscreen
import XMonad.Layout.NoBorders

myWorkspaces = ["1:term","2:web","3","4","5","6", "7:tray","8","9:vm"]
myLayout =
 avoidStruts (
     noBorders (fullscreenFull Full)
     ||| Tall 1 (3/100) (60/100) 
     ||| Mirror (Tall 1 (3/100) (1/2)))

main = do
    xmproc <- spawnPipe "xmobar"
    xmonad $ defaultConfig
        {manageHook  = manageDocks <+> manageHook defaultConfig
        --, layoutHook = avoidStruts  $ layoutHook defaultConfig
        , layoutHook = smartBorders $ myLayout
        -- this event hook ensure xmobar visible with full screen application
        -- this must be in this order, docksEventHook must be last
        , handleEventHook = handleEventHook defaultConfig <+> docksEventHook
        , logHook = dynamicLogWithPP xmobarPP
                      { ppOutput = hPutStrLn xmproc
                        , ppTitle = xmobarColor "green" "" . shorten 50
                        , ppHiddenNoWindows = xmobarColor "grey" ""
                      }
        , modMask = mod4Mask     -- Rebind Mod to the Windows key
        , workspaces         = myWorkspaces

        } `additionalKeys`
        [ ((mod4Mask .|. shiftMask, xK_z), spawn "xscreensaver-command -lock; xset dpms force off")
        , ((controlMask, xK_Print), spawn "sleep 0.2; scrot -s")
        , ((0, xK_Print), spawn "scrot")
        -- a basic CycleWS setup
        -- Switch to the next/prev workspace.
        , ((mod4Mask,               xK_Down),  nextWS)
        , ((mod4Mask,               xK_Up),    prevWS)
        --  Move the focused window to the next/prev workspace.
        , ((mod4Mask .|. shiftMask, xK_Down),  shiftToNext)
        , ((mod4Mask .|. shiftMask, xK_Up),    shiftToPrev)
        , ((mod4Mask,               xK_Right), nextScreen)
        , ((mod4Mask,               xK_Left),  prevScreen)
        , ((mod4Mask .|. shiftMask, xK_Right), shiftNextScreen)
        , ((mod4Mask .|. shiftMask, xK_Left),  shiftPrevScreen)
        , ((mod4Mask,               xK_z),     toggleWS)
        -- Swaps focused window with the master window. If focus is in the master, 
        -- swap it with the next window in the stack. Focus stays in the master.
        , ((mod4Mask,               xK_Return), dwmpromote)
        ]
```

.xmobarrc
```txt
Config { --font = "-*-Fixed-Bold-R-Normal-*-16-*-*-*-*-*-*-*"
    font = "xft:monospace-12",
       , additionalFonts = []
       , borderColor = "black"
       , border = TopB
       , bgColor = "black"
       , fgColor = "grey"
    -- right_padding = num_icons * icon_size
    -- right_padding = 6 * 25 = 150
       , position = TopP 0 150,
       , textOffset = -1
       , iconOffset = -1
       , alpha = 255
       , lowerOnStart = False
       , hideOnStart = False
       , pickBroadest = False
       , persistent = True
       , iconRoot = "."
       , allDesktops = True
       , overrideRedirect = False
       , commands = [ Run Weather "ZUUU" ["-t","<station>: <tempC>C","-L","18","-H","25","--normal","green","--high","red","--low","lightblue"] 36000
             , Run Network "eth0" ["-L","0","-H","32","--normal","green","--high","red"] 10
             , Run Network "eth1" ["-L","0","-H","32","--normal","green","--high","red"] 10
             , Run Cpu ["-L","3","-H","50","--normal","green","--high","red"] 10
             , Run Battery [ "--template" , "Batt: <acstatus>"
               , "--Low"      , "10"        -- units: %
               , "--High"     , "80"        -- units: %
               , "--low"      , "darkred"
               , "--normal"   , "darkorange"
               , "--high"     , "darkgreen"
               , "--" -- battery specific options
                      -- discharging status
               , "-o"	, "<left>% (<timeleft>)"
                      -- AC "on" status
               , "-O"	, "<fc=#dAA520>Charging</fc>"
                      -- charged status
               , "-i"	, "<fc=#006000>Charged</fc>"
             ] 50
             , Run Memory ["-t","Mem: <usedratio>%"] 10
             , Run Swap [ ] 10
             , Run Date "%H:%M:%S %m/%d %u" "date" 10
             , Run StdinReader
             ]
, sepChar = "%"
, alignSep = "}{"
, template = "%StdinReader%|%cpu%|%memory%|%swap%}{<fc=#ee9a00>%date%</fc>"
}
```

.stalonetrayrc
```txt
# 1 row of 12 icons, each 23px wide/tall. Resolution 3840x2160.
# This icon size aligns with the size of xmobar with font "xft:monospace-8"
# position = display_width - (num_icons * icon_size)
# position = 1366 - (6 * 25) = 1216
# Example: geometry 6x1+3564  6 icons wide and 1 icon high
geometry 6x1+1216
icon_size 25
sticky 1
window_type dock
dockapp_mode wmaker
window_strut auto
skip_taskbar 1
icon_gravity NE
background black
kludges force_icons_size
```

.xsessionrc
```txt
#!/bin/bash

# Load resources
xrdb -merge .Xresources

# Set up an icon tray
stalonetray &

# Fire up apps
xscreensaver -no-splash &

# xmodmap ~/.Xmodmap &
feh --bg-scale /home/tao/Pictures/back.jpg &

export GTK_IM_MODULE=fcitx
export QT_IM_MODULE=fcitx
export XMODIFIERS=@im=fcitx
fcitx &

# Start udiskie to handle media
udiskie &

xfce4-power-manager &

if [ -x /usr/bin/nm-applet ] ; then
   nm-applet --sm-disable &
fi

# put teminator behind fcitx to make it work 
# block the stalonetray back black
terminator &
lantern &

exec xmonad
```
for now, fcitx can't input shuangpin chinese...to be done.
2019-09-14 09:32:14 注:
发现fcitx在终端中无法输入的原因是fcitx在启动terminal后定义的，所以修改.xsessionrc文件将
启动terminator放到最后即可。以上配置文件已修改为正确配置。

## Ubantu安装Typora 
之前是使用pandoc将markdown文件转换为epub文件放到kindle中，发现效果不好，后来发现了
donot print插件可以很方便的重组pdf方便不同设备阅读pdf,所以想到可以安装typora先将markdown
转换为pdf, 再进行重组，初步看效果不错。以下将安装过程记录下:
```txt
sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE
sudo add-apt-repository 'deb http://typora.io linux/'
sudo apt install typora
```
注: 使用pandoc将html转换为pdf效果不好，还需要安装一个很大的pdflatex引擎(textlive-full)

## Terminator theme 
在Terminator中安装Dracula主题，将安装步骤记录如下:
```txt
pip install requests
mkdir -p $HOME/.config/terminator/plugins
wget https://git.io/v5Zww -O $HOME"/.config/terminator/plugins/terminator-themes.py"
preference --> plugin --> terminator theme
theme --> dracula --> install
// 如果点击theme无反应，使用sudo apt install python-requests命令
vi ~/.config/terminator/config
replace Dracula with default under profiles setting
```

## Linux处理usb设备 
```txt
sudo fdisk -l  # 查看分区情况，可以看到插入的usb设备，类型一般为dos?也可通过size判断
               # 还可以看见usb的格式类型
sudo mkdir -p /mnt/usb  # 创建挂载点
sudo mount /dev/sdb3 /mnt/usb # 挂载  分区点根据实际情况变化
sudo umount /dev/sdb3     # 卸载
```

## Ubantu 18.04上安装vmware workstation 15.0.3
用虚拟机办公很久了，今天启动时突然又报错`before you can run VMware, some modules must be 
compiled and loaded into the running kernel`, 点击install时是必定失败的，日志报错为
```txt
Failed to build vmmon and Failed to build vmnet.
```
之前报这个错是因为不小心升级了内核版本，后来
自己回退了版本(上文有记录方法)后又可以正常使用了。但今天没有升级内核又报这个错, 上次查问题时
查到vmware需要安装一个补丁，当时试了没用就没管它，今天又搜到该方法的文章，试了成功了!
作者提供了一个脚本，执行后即可正常启动vmware.(拯救了工作机器，Thank God!)
```txt
#!/bin/bash
#This needs to be the actual name of the appropriate branch in mkubecek's GitHub repo for your purposes
VMWARE_VERSION=workstation-15.0.3 
TMP_FOLDER=/tmp/patch-vmware
rm -fdr $TMP_FOLDER
mkdir -p $TMP_FOLDER
cd $TMP_FOLDER
#Use `git branch -a` to find all available branches and find the one that's appropriate for you
git clone https://github.com/mkubecek/vmware-host-modules.git 
cd $TMP_FOLDER/vmware-host-modules
git checkout $VMWARE_VERSION
git fetch
make
sudo make install
sudo rm /usr/lib/vmware/lib/libz.so.1/libz.so.1
sudo ln -s /lib/x86_64-linux-gnu/libz.so.1 /usr/lib/vmware/lib/libz.so.1/libz.so.1
systemctl restart vmware && vmware &
```

下面记录下安装vmware workstation pro 15 过程。
```txt
download install package, e.g., VMware-Workstation-Full-15.0.3-12422535.x86_64.bundle
sudo apt update
sudo apt upgrade
sudo apt install gcc build-essential  # install prerequisites packages
sudo ./VMware-Workstation-Full-15.0.3-12422535.x86_64.bundle

# input product activate code  one of down
UY758-0RXEQ-M81WP-8ZM7Z-Y3HDA
VF750-4MX5Q-488DQ-9WZE9-ZY2D6
UU54R-FVD91-488PP-7NNGC-ZFAX6
YC74H-FGF92-081VZ-R5QNG-P6RY4
YC34H-6WWDK-085MQ-JYPNX-NZRA2
=================
https://www.luochenzhimu.com

sh vmware.sh   # content as above
```
执行脚本中可以看到vmwareworkstation pro 15.0.3版本已经不再更新了，最新版已经到15.1.x了，
15.0.3支持的kernel版本是5.2.(我现在是5.0.0-27-generic)
为了防止激活码过期，还是不要升级了vmwareworkstation了，同时内核版本也可以不升。

## Ubantu 18.04 升级内核版本并开启bbr算法
1. 升级内核
简单的做法是在线升级`sudo do-release-upgrade`(待测试), 还可以自己下载内核deb包手动升级内核.
一般是2个header, 1个image, 用`sudo dpkg -i *.deb`即可(待测试).
2. 开启bbr算法
bbr是google开发的提高网络带宽利用的拥塞控制算法，简单来说就是可以网络加速, 主要是用来提高
上传速度，配置在服务器上时"上传"给客户端即相当于提升了客户端的下载速度，非常适合给自己的
云服务器或VPN服务器安装.Linux 内核4.9版本开始预安装该算法，我刚好5.0.0, 下面就来开启一下。
```txt
开启bbr
$ sudo su
# echo "net.core.default_qdisc=fq" >> /etc/sysctl.conf
# echo "net.ipv4.tcp_congestion_control=bbr" >> /etc/sysctl.conf
// 保存
# sysctl -p
// 查看是否开启
$ sysctl net.ipv4.tcp_available_congestion_control
net.ipv4.tcp_available_congestion_control = bbr cubic reno

$ lsmod | grep bbr
tcp_bbr                20480  0

关闭bbr
$ sed -i '/net\.core\.default_qdisc=fq/d' /etc/sysctl.conf
$ sed -i '/net\.ipv4\.tcp_congestion_control=bbr/d' /etc/sysctl.conf
$ sysctl -p
// 查看是否关闭
$ lsmod | grep bbr
```

## linxu 获取root权限命令
```txt
To get root access, you can use one of a variety of methods:

Run sudo <command> and type in your login password, if prompted, to run only that instance 
of the command as root. Next time you run another or the same command without the sudo 
prefix, you will not have root access.

Run sudo -i. This will give you an interactive root shell. Note that the $ at the end of 
your prompt has changed to a #, indicating that you have root access. But you fall in the 
root home directory (/root/). From here you can run any sequence of commands as root, or 
run the command exit to leave the root shell.

Use the su (substitute user) command to get a root shell. This is effectively the same as 
using sudo -i. Note that when you use this command it will ask for the root password and 
not your login password. These are not the same. You may have to set or change the root 
password by running sudo passwd root first.

Run sudo -s. This gives you root access, but maintains your current SHELL. Shell specific 
settings, including your current directory, are preserved. For instance if you use bash 
(Ubuntu's default shell), aliases (and any other settings from ~/.bashrc) are kept when 
you switch to the root user. To leave the root access, type exit as in the cases above.
```
从以上可以看出，最实用的是`sudo su`,可以保留我的fish shell环境。
开启后提示符会由`$`变为`#`号, 使用完后使用exit退出即可。

## Linux删除旧内核版本
可以删除旧内核节省一点硬盘空间。
```txt
sudo su

dpkg -l | grep linux-image
apt purge linux-image-4.15* -y

// 注意headers 5.0.0.27-generic依赖于5.0.0.27，卸载了5.0.0.27后generic也没有了,
// 还需要apt install 装回来...
dpkg -l | grep linux-headers    
apt purge linux-headers-4.15* -y

dpkg -l | grep linux-modules
apt purge linux-modules-4.15* -y
```

## 实现iphone上写java代码并运行
突然想到如何在手机上运行java代码，上网搜一下，果然有！搜到一个支持jdk7的app可以运行java代码，
不过需要收费，还花18元买了一个Koder，但是点进去运行总报错"are you connected to internet",
看评论知道应该是不能用了，浪费了钱......总结下来，觉得靠谱的方案是:
`在手机上装git客户端，在手机上commit后利用Travis的持续集成功能查看程序运行结果!`, 这应该是
最简便的方案了，但如果有自己的云服务器的话(以后不用蓝灯了要搞一个), 可以在手机上装一个SSH
工具，直接链接到服务器上，这样可支持的功能更多。
实现步骤:
1. 建立github仓库，上传项目
2. Travis关联到github上。
3. 项目中的.travis.yml文件为
```txt
language: java
jdk:
  - openjdk8
cache:
  directories:
    - $HOME/.m2
script: mvn test
```

由于travis是由ruby写的，ruby的依赖是系统范围的，不是针对某个项目的，所以它对于maven项目会
默认执行命令`mvn install -DskipTests=true -Dmaven.javadoc.skip=true -B -V`, install属于
default生命周期中较后面的一个阶段，包括了源码和测试代码的编译。而`-DskipTests=true`不会
执行单元测试，但仍然会编译单元测试生成class文件，`-Dmaven.test.skip=true`即不会编译也不会
执行单元测试。所以Travis已经编译过了新的测试代码，我们不需要clean, 直接执行单元测试即可。

4. 想要看到程序的执行结果时直接在相应的单元测试下打印即可，maven执行单元测试时会打印出来。
5. 手机上使用git app(Working Copy, push需要解锁专业版100元！发现codeHub commit就是push!免费!)
进行推送测试即可。
6. codeHub就是界面没有working copy方便，但是免费!使用open in 存储到文件->Documents, 再
用ivim(:idocuments)打开下载的文件，全选(set clipboard=unnamed有效!)后复制y, 回到codeHub
edit文件粘贴, commit后查看Travis运行日志，到这里就实现了手机写代码并查看运行结果了!
注: ivim单手指长按是隐藏扩展小键盘，双手指长按是隐藏整个键盘，双手指可以上下拖动屏幕。

## 命令行批量命名文件
从InfoQ上下载了一批电子书，打算放到kindle上观看，但是下载文件的文件名都是一长串随机字符，
想要批量进行修改，于是想到使用终端命令一次性搞定(当然不可能逐个mv)！
1. mac上操作
```txt
brew install rename
// 这个版本的rename有-N参数，支持自动递增的文件名 
rename -n -N 01 's/.*.mobi/infoQ-ebook-$N.mobi/' *.mobi
// -n 代表dry-run, 演示重命令效果，并不真正操作
// -N 代表递增参数后面的perl表达式中使用$N来表示递增变量 01是占位符 结果为01, 02, 03...
```
2. ubuntu 18.04上操作

```txt
sudo apt install rename
man rename
// 可以看到这个rename版本不支持-N参数
// 因为后面的表达式是perl表达式，所以想着自定义perl变量来递增，如下
rename -n 'our $d=0;s/.*.md/$d++/e' *.md
// 看到结果为全部命名为0, 原因为变量d每次执行时都被初始化为0,所以没有实现递增，而且后面的
// 替换不能直接写...
// google上搜索到这时可以使用管道一次读取全部文件名，再进行逐一操作，如下
ls -1 -c | xargs rename -n 's/.*.md/our $i; sprintf("%02d.md", $i++)/e'
```

如果不用rename, 还可以这样写

```txt
ls -v | cat -n | while read n f; do mv -n "$f" "$n.md"; done 
```
可以看到这里充分利用了管道的功能，ls列出所有要重命名的文件名，交给cat命令使用-n进行编号，
最后使用mv命令循环重命名。这种方式最为通用，不用额外依赖rename命令。


<hr />
<img src="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/201901311.jpg" class="full-image" />

