---
title: VueNote
categories: Vue
tags:
  - Vue
updated: 2019-11-22 18:07:56
date: 2019-11-19 17:23:01
abbrlink:
---
note on learning Vue
<!-- more -->
## 官网教程

### 安装
直接下载vue.js并在html中引用即可。这里使用的vue版本为2.6.10.

### 声明式渲染，条件与循环等
数据可以绑定到DOM文本:如文本插值{{ message }}, 
DOM属性: 如直接在html标签中使用指令v-bind:title="eleTitle"改变鼠标悬停效果,
DOM结构: 如使用指令v-if="seen"控制是否显示标签(控制结构时还可以提供fade in, out等其他动画效果)

v-for="item in itemList"在li标签中的应用。
v-on:click="afterClick"绑定点击事件为afterClick方法。
v-model="message"为双向数据绑定。

可以通过如下方式自定义组件:
```txt
Vue.component('todo', {
  props: ['prop1', 'prop2'],
  template: '<li>{{ prop1.text }}</li>'
});

var ele = new Vue({
 el: '#ap5',
 data: {
   list: [
    {id: 0, text: 'one'},
    {id: 1, text: 'two'},
    {id: 2, text: 'three'}
   ]  
 }
});
```
自定义组件，使用时如
```txt
<div id='ap5'>
  <todo v-for="item in list" v-bind:prop1="item" v-bind:key="item.id"/>
</div>
```
可以看到，自定义组件todo使用组件属性prop使得组件动态显示外界传递的数据内容。这与上面的
v-bind:title="message"是一样的。

### Vue实例
在vue中，一个组件实际上是一个预定义的Vue实例。每个Vue实例可以接受多个选项。
1. 数据选项 data
当实例创建时，data选项中已经存在的属性会被加入到vue的响应式系统中，如
```txt
var dataSource = {text: 1};
var vm = new Vue({
  data: dataSource 
});
```
这时无论改变vm.text还是改变dataSource.text的值，另一个的值都会同步发生改变，即实现了数据
和视图的双向响应式变化。如果在vm实例创建后，对dataSource添加新属性是无法实现响应式变化的。

注: Object.freeze(dataSource)会阻止修改对象属性值。

实例属性和方法都有前缀$, 如vm.$el, vm.$data等。

实例提供了多个生命周期钩子，如created, mounted, updated, destroyed等，可以在选项中自定义
回调方法执行自定义操作。钩子的this关键字指向vue实例，避免使用箭头函数。

教程中给出了vue实例的整个生命周期流程，可以看到以下几点：
1. 如果没有指定el选项，可以使用vm.$mount(el)方法指定元素。
2. 选项中如果有指定template模板，使用该模板进行渲染，否则就使用el的html标签进行渲染。这一点
也区分开了自定义组件和普通的html标签。
3. vue使用vm.$el替换原生的el标签实现虚拟DOM, 在此基础上实现响应式渲染。 

### 模板语法
#### 插值
1. 文本
双大括号为mustache语法，{{ message }}, 数据选项属性message发生变化，该文本值也会变化。
可以使用`<p v-once>{{ message }}</p>`来实现一次性渲染.

注: 类似document.getElementById().innerText = XXX;

2. html标签
```txt
<div id='ap6'>
  <p><span v-html="sp"/></p>
</div>

var ap6 = new Vue({
  el: '#ap6',
  data: {
    sp: '<a style='color: red'>I am red</a>'
  }
})
```
对用户输入的内容使用html插值容易导致XSS攻击，应只对可信内容使用。

注: 类似`document.getElementById().innerHTML = "<x>...</x>";`

3. 属性 
同上面所说，标签属性的改变使用v-bind指令，如v-bind:disabled="disableFlag"等, 其中disableFlag
必须为boolean值。

4. 模板表达式
如{{ num + 1}}, {{ ok ? 'yes' : 'no' }}都会被当作js表达式解析，其中num作为v-model双向绑定时
是字符串类型，{{num+1}}得到的是字符串的拼接。
模板表达式的解析是在沙盒中，只能访问如Math,Date等白名单对象，无法访问用户自定义全局变量，
访问时会报错该属性未定义。

#### 指令
指令一般是作用于单个表达式，如v-on:click='reverse', v-if='seen'等。
1. 参数 
即指令名称冒号后的值，如v-bind:href='url', v-on:click='reverse'中href, click都是参数，
等号后是参数值。

2. 动态参数
如v-on:[event]='dosth', 其中event可以为一个js表达式，如实例中有一个数据属性为event,值为
focus, 那么它就等价为v-on:focus='dosth'.通过这种形式，该标签就可以在不同时间以聚焦或点击
的不同动作调用相同的方法。(这种需求还是比较少见, 其他指令的参数动态性可能有点用)
动态表达式中不能有空格和引号，大写字母会被强制转换为小写。

3. 修饰符
如v-on:submit.prevent='sub'中参数submit后的.prevent指出该指令以特殊方式绑定，即调用
event.preventDefault()语句。

#### 缩写
v-bind:href='url'可以缩写为:href='url',
v-on:click='dosth'可以缩写为@click='dosth'.

### 计算属性和侦听器
#### 计算属性
在模板表达式中写比较复杂的算式可读性不好，而且不方便复用。这时可以使用计算属性。如:
```txt
<p>{{ reverseTxt }}</p>

var ap7 = new Vue({
  el: '#ap7',
  data: {
    txt: 'sdg'  
  },
  computed: {
    reverseTxt: function() {
      return this.txt.split('').reverse().join('');  
    }
  }
});
```
计算属性与方法的不同在于计算属性自带缓存，当this.txt没有发生改变时，不会重新计算直接返回
缓存值。
计算属性与侦听器的不同在于计算属性可以同时监控多个属性的变化，而侦听器只能针对单个属性的变化
分别定义函数。
计算属性默认是get方法，即计算结果值由"监测"的属性计算得到，但也可以通过设置计算属性值反过来
设置监测的属性值。通过这种联动可以实现实例中属性的双向影响，感觉在某些场景中这种相互影响非常
实用。代码如:
```txt
computed: {
 reverseTxt: {
   get: function() {
      return this.txt.split('').reverse().join('');  
   },
   set: function(val) {
      this.txt = val.split('').reverse().join('');  
   }
 } 
}
```

侦听器在属性值发生变化时可以调用相应的函数，如发出ajax异步请求等。为防止请求过于频繁，教程中
使用lodash的debounce方法限制请求间隔，使用axios发出ajax请求。

### class与style绑定
v-bind指令在设置标签的样式如class, style属性时除了字符串，还可以绑定一个对象或数组。
1. class
传递对象:
如`<p v-bind:class="{real: isReal, active: isActive}"></p>`,这个绑定的对象
除了可以在这里直接定义，还可以定义在实例的data选项属性中，或是计算属性中(更强大的控制)。

其中，对象的属性名是具体的class名称，属性值是该class是否生效的boolean值。为truthy时该class
生效，为false时该class不生效。
注: **js中除false, 0, "", null, undefined, NaN以外，都是真值，即为truthy.**

实例中定义为`data: {isReal: true, isActive: false}`.

注: v-bind:class可以和普通的class属性共存。

传递数组:
比起使用boolean值控制class列表的对象语法，数组语法通过class列表的字符串数组进行控制，
如`v-bind:class="[aClass, bClass]"`，同理，为实现控制，这里的aClass,bClass是实例的属性名，
实例中有`data: {aClass: 'a', bClass: 'b'}`, a和b即为具体的class名称。当需要去除某个class时，
将对应属性值设置为''即可。如果需要动态控制，可以在数组语法中嵌套使用对象语法，
如`v-bind:class='[{aClass: aflag}, bClass]`.

用在组件上:
在自定义组件中通过以上2种方式带数据绑定的class会追加到组件的根元素中，不会覆盖已有的class列表。 

2. style
通过style绑定的是内联样式，直接指定样式，不需要中间的class层，适合样式少并分散的情况。

对象语法:
如`v-bind:style="{color: acolor, fontSize: fs + 'px'}"`, 实例中定义
`data: {acolor: 'red', fs: 30}`, 
同样的，可以将该对象定义在实例data中，或使用计算属性。
如`v-bind:style="sty"`, `data: {sty: {color: 'red', fontSize: '30px'}}`.

数组语法:
style的数组语法可以使用多个style对象进行控制，这里使用对象语法一个style对象即可以控制，
所以数组语法意义不大，就此略过。

自动添加前缀: 对于非标准的浏览器引擎CSS前缀，v-bind:style会自动添加前缀，可忽略。
多重值: style样式属性值除字符串外，还可以传递数组，vue会选择数组中最后一个支持的浏览器样式，
可忽略。

### 条件渲染
1. v-if
在单个标签中使用v-if="seen", 当seen为false时，刷新后该标签一闪而过后消失。应该是渲染的执行
顺序问题。当需要控制隐藏多个标签时，使用template标签并在其中使用v-if指令，发现没有出现闪烁
现象。

v-if后可以使用v-else-if，v-else指令块控制多个元素的显式隐藏。要求必须相应的元素必须紧靠在
一起，否则无法识别。

当使用v-if切换2个template元素组时，vue会复用已经有的元素，这样在切换时会出现元素中已有的
值(如用户的输入值)不会被清空的情况。这时可以给这2个template中相同的元素设置key属性，相当于
指定了id, 通过设置不同的key值，vue就不会复用该元素。而未指定key时，vue将复用相同元素提高
渲染速度。

2. v-show
v-show指令值为false时相当于style='display:none"，所以v-show元素始终存在于dom中。

注: v-if是真正的条件渲染，而且是惰性的(只有第一次为真时才开始渲染)，切换开销较大；而v-show
始终会渲染，初始开销大，但切换时只是CSS变换，切换开销小。
所以如果频繁切换应使用v-show, 切换较少时使用v-if.

注: 不应当在同一个元素内同时使用v-if和v-for指令，因为v-for指令优先级更高，这样当只需要渲染
其中一小部分元素时，却遍历了整个列表进行判断。这时应当使用计算属性过滤出需要的列表，对其
使用v-for指令渲染，这样更高效，而且将筛选逻辑解耦出来了(而且计算属性还自带缓存，可以复用)。

### 列表渲染
1. 渲染列表
v-for指令在li标签上使用可以渲染一个列表。
```txt
<li v-for="item in items">{{ item.txt }}</li>
data: {
  items: [
    {txt: "one"},
    {txt: "two"},
  ]
}
```
v-for还可以写为`v-for="(item, index) in items"`, index为自动添加的索引。
还可以使用of代替in, 如`v-for="(item, index) of items"`。

2. v-for中使用对象
如
```txt
<li v-for="value in obj">{{value}}</li>
data: {
  obj: {
    title: 'tt',
    name: 'ss'
  } 
}
```
同时显示对象属性名和值:
```txt
<li v-for="(value, name) in obj">{{name}}: {{value}}</li>
或
<li v-for="(value, name, index) in obj">{{index}}:{{name}}: {{value}}</li>
```
注: 模板表达式只能识别单个属性，{{name: value}}会报错。
遍历顺序为Object.keys()结果。

3. 维护状态
同前面v-if的元素复用类似，v-for指令在未指定key时使用默认的"就地更新"策略，即不会主动更改
dom元素位置，而是更新每个元素值。这种模式很高效，但它只适用于输出的DOM非常简单的情况。
一般建议是在使用v-for指令时，同时使用v-bind:key="item.id"值为每一个列表项指定id.
使用key后，会强制更新元素或组件而不是重复利用已有元素，适用于触发过渡效果。

4. 数组更新检测
当v-for的数组内容发生变化时，对应的列表也会发生变化，数组变化的方法有
push, pop, shift, unshift, splice, sort, reverse.这些方法会改变原数组，而其他另外一些方法
如filter, concat, slice等没有改变原数组，这时如果想要重新渲染列表，可以使用计算属性，
在其中将得到的新数组替换原属性即可(vue会尽量复用已有DOM, 不会马上销毁原有DOM重新渲染)。

注: 直接使用索引修改元素值如a[i] = 3和a.length = 3无法实现响应式更新。对于前者可以使用
Vue.set(vm.items, index, newValue)或vm.items.splice(index, 1, newValue),
对于后者可以使用vm.items.splice(newlength).

splice意思是拼接，splice(startIndex, deleteCount, item1, item2...)意为从startIndex(包括)开始删除
deleteCount个字符，并在相同位置插入元素item1, item2..., 该方法改变了原数组，方法的返回值是
被删除的元素数组。

5. 对象变更检测
前面说过，对于已经初始化完成的vue实例，后面再添加属性值是不支持响应式更新的。(即时支持
好像也没有实际作用)。但可以对属性对象进行修改。
如果添加单个属性可以使用`Vue.set(vm.obj, 'name', 29)`添加或修改属性，如果要添加多个时，
可以使用`vm.obj = Object.assign({}, vm.obj, {'name':29, 'sex': 'm'});`
这里新建一个vm.obj对象而不是直接`Object.assign(vm.obj, {...})`的原因经网上搜索，说如果直接
修改vm对象，可能会导致基于vm的元素出现渲染问题，所以还是使用新对象较好。而且使用{}当vm.obj
对象为undefined时不会报错。即assign的源对象可以为undefined. 

注: Object.assign()复制的是属性值，为浅拷贝，如果需要深拷贝，可以json序列化后再解析，即
let copy = JSON.parse(JSON.stringify(source));

6. 显示过滤/排序后的结果
前面已经说过，需要过滤时应使用计算属性或方法对数组处理后再使用v-for指令渲染(直接使用v-if
性能低，耦合度高)。在使用v-for循环嵌套时，列表不是data属性(是数据内部的次级列表)，无法直接
访问所以不能使用计算属性，只能使用方法来处理。

7. v-for使用值范围
`<p v-for="n in 10">{{n}}</p>`输出12345678910

8. template上使用v-for
对于一组需要多次重复的元素组，可以在template上使用v-for. 具体需求如表格。
```txt
<div id="b4">
      <table>
              <template v-for="row in rows">
                      <tr>
                              <td>{{row.a}}</td>
                              <td>{{row.b}}</td>
                      </tr>
              </template>
      </table>
</div>
var b4 = new Vue({
      el: '#b4',
      data: {
              rows: [
                      {a: '11', b: '12'},
                      {a: '21', b: '22'}
              ]
      }
});
```
9. 组件上使用v-for
前面说过，组件中应使用key区分每个列表内元素保证渲染正确。同时组件有自己的作用域，需要使用
prop来传递数据。
```txt
<ul>
  <li is="myComponent" 
  v-for="(item,index) in list" 
  :key = "item.id"
  :content = "item.text"
  @remove="list.splice(index, 1)"
  />
</ul>
```
其中is="myComponent"是因为html限制ul中只有li是有效标签，要在其中使用自定义元素myComponent
时，需要通过is进行标记。key为item.id, 组件props属性(数组)为`['content']`(即li标签显示内容),
赋值为item.text.最后是点击按钮触发remove事件时将数组中该项去除，这样会同步响应到视图中。

### 事件处理
1. 内联语句
如v-on:click="count += 1"可以让属性count自增1
2. 绑定到方法
使用如v-on:click="afterClicked"将动作绑定到实例方法，处理逻辑都在方法中定义。
3. 内联语句中调用方法
如v-on:click="say('oneClick')", 在内联语句中调用方法。此时可以用$event向方法中传入原生
DOM事件，如v-on:click="say('oneClick', $event)".
4. 事件修饰符
某些情况需要阻止事件的默认行为，如form表单提交的默认重载页面行为，一般是使用
event.preventDefault(), vue提供了修饰符简化该操作，如
```txt
.stop 阻止事件继续传播 
.prevent 阻止事件默认行为
.capture 捕获内部元素事件，捕获处理完毕后再交还子元素
.self 只处理自身的事件，内部元素触发的事件不进入该处理
.once 该事件方法只会被调用一次
.passive 告诉浏览器执行事件的默认行为(正好与.prevent相反), 
         与.prevent一起使用时.prevent会被忽略
```
5. 按键修饰符
监听键盘事件时，可以指定按键。
如v-on:keyup.enter="submit"回车键调用submit方法，
v-on:keyup.page-down="onPageDown"按下pageDown键时调用onPageDown方法。
键名可以使用KeyboardEvent.key得到。
可以通过以下方式获取:
```txt
 <div id="b5">
      <input @keyup="go($event)"/>
</div>

var b5 = new Vue({
      el: '#b5',
      methods: {
              go: function (e) {
                      console.log(e.key);
              }
      }
});
```
注：按键码keycode用法已经被废弃，应避免使用

6. 系统修饰键
键盘修饰键只有在按下时才能触发，有
```txt
.ctrl
.alt
.shift
.meta
```
如alt+c触发clear方法: <input @keyup.alt.c="clear">，
完整代码如下:
```txt
<div id="b5">
    <input @keyup.alt.c="clear" v-model="mess"/>
</div>
var b5 = new Vue({
      el: '#b5',
      data: {
              mess: ''
      },
      methods: {
              clear: function () {
                      this.mess = '';
              }
      }
});
```
上面的`@keyup.alt.c="clear"`当alt和其他的修饰键如ctrl, shift等一起按下时也会调用，使用
.exact修饰符可以控制只有alt被按下时才会调用clear方法,代码为`@keyup.alt.exact.c="clear"`.

7. 鼠标按钮修饰符
.left .right .middle

### 表单输入绑定

#### 基础用法
v-model实际是语法糖，它监听用户的输入事件并更新数据。
v-model适用于input, textarea, checkbox, radio, select元素。

text, textarea, select根据value属性的变化触发input事件。
checkbox, radio根据checked属性的变化触发change事件。

v-model绑定的值为元素值。如`<input type='checkbox' value='one' v-model='arr'>`中，复选框
选中时arr数组中有值one, 未勾选时无值one. 代码如下:
```txt
<div id="b6">
      <input type="checkbox" value="one" v-model="arr"/><label>one</label>
      <input type="checkbox" value="two" v-model="arr"/><label>two</label>
      <p>{{arr}}</p>
</div>

var b6 = new Vue({
      el: '#b6',
      data: {
              arr: []
      }
});
```
使用`<textarea>{{mess}}</textarea>`无法实现双向绑定，只有初始时可以成功渲染mess值，用户
在输入文本后，mess值并不会相应的变化，若要实现双向绑定必须使用`<textarea v-model='mess'/>`.

select下拉框:
```txt
<div id="b7">
      <select v-model="sel">
              <option disabled value="">please select</option>
              <option>A</option>
              <option>B</option>
              <option>C</option>
      </select>
      <p>{{sel}}</p>
</div>

var b7 = new Vue({
      el: '#b7',
      data: {
              sel: ''
      }
});
```
多选下拉框除绑定到一个数组外，标签使用multiple标记为可多选，具体选择时按住ctrl键可多选
`<select v-model='selected' multiple>...</select>`

#### 值绑定
以上使用v-model时单选框，复选框，下拉框的值都是静态的，为字符串(复选框可以为boolean值)。
实际使用时如下拉框，选中的选项需要绑定到一个对象，这时简单的绑定方式`<option>A</option>`
(该选项值为A)就不能满足需求，这时可以进一步对选项的值进行绑定，即值绑定。

即`<option v-bind:value="{name: 'zs', age: 20}"`.这样通过v-bind指令对value属性进一步绑定
即可满足要求。

如下代码展示了下拉框联动后获取子下拉框选择的具体对象信息:
```txt
<div id="b8">
      <select v-model="parent" @change="changeList">
              <option disabled value="">please select one</option>
              <option>a</option>
              <option>b</option>
      </select>
      <select v-model="child">
              <option disabled value="">please select one</option>
              <option v-for="item in list" :key="item.id" :value="item">{{ item.name }}</option>
      </select>
      <p>id: {{child.id}}</p>
      <p>name: {{child.name}}</p>
      <p>age: {{child.age}}</p>
</div>

var b8 = new Vue({
      el: '#b8',
      data: {
              parent: '',
              child: {},
              list: []
      },
      methods: {
            changeList: function () {
                  if (this.parent == 'a') {
                          this.list = [
                                  {id: 1, name: 'a1', age: 11},
                                  {id: 2, name: 'a2', age: 22}];
                  }else{
                          this.list = [
                                  {id: 3, name: 'b1', age: 33},
                                  {id: 4, name: 'b2', age: 44}];
                  }
            }
      }
});
```
可以注意到，要获取子下拉框选择的对象信息，直接绑定`:value="item"`.















### 组件基础

### 组件注册
### Prop
### 自定义事件
### 插槽
### 动态组件&异步组件
### 处理边界情况

### 进入/离开&列表过渡
### 状态过渡

### 混入
### 自定义指令
### 渲染函数&JSX
### 插件
### 过滤器

### 单文件组件 
### 单元测试
### TypeScript支持
### 生产环境部署

### 路由 
### 状态管理
### 服务端渲染

### 深入响应式原理

##

##
<hr />
<img src="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/20191119_1.jpg" class="full-image" />
