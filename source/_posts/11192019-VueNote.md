---
title: VueNote
categories: Vue
tags:
  - Vue
updated: 2019-12-04 18:06:49
date: 2019-11-19 17:23:01
abbrlink:
---
note on learning Vue
<!-- more -->
## 官网教程

### 安装
直接下载vue.js并在html中引用即可。这里使用的vue版本为2.6.10.

### 声明式渲染，条件与循环等
数据可以绑定到DOM文本:如文本插值{{ message }}, 
DOM属性: 如直接在html标签中使用指令v-bind:title="eleTitle"改变鼠标悬停效果,
DOM结构: 如使用指令v-if="seen"控制是否显示标签(控制结构时还可以提供fade in, out等其他动画效果)

v-for="item in itemList"在li标签中的应用。
v-on:click="afterClick"绑定点击事件为afterClick方法。
v-model="message"为双向数据绑定。

可以通过如下方式自定义组件:
```txt
Vue.component('todo', {
  props: ['prop1', 'prop2'],
  template: '<li>{{ prop1.text }}</li>'
});

var ele = new Vue({
 el: '#ap5',
 data: {
   list: [
    {id: 0, text: 'one'},
    {id: 1, text: 'two'},
    {id: 2, text: 'three'}
   ]  
 }
});
```
自定义组件，使用时如
```txt
<div id='ap5'>
  <todo v-for="item in list" v-bind:prop1="item" v-bind:key="item.id"/>
</div>
```
可以看到，自定义组件todo使用组件属性prop使得组件动态显示外界传递的数据内容。这与上面的
v-bind:title="message"是一样的。

### Vue实例
在vue中，一个组件实际上是一个预定义的Vue实例。每个Vue实例可以接受多个选项。
1. 数据选项 data
当实例创建时，data选项中已经存在的属性会被加入到vue的响应式系统中，如
```txt
var dataSource = {text: 1};
var vm = new Vue({
  data: dataSource 
});
```
这时无论改变vm.text还是改变dataSource.text的值，另一个的值都会同步发生改变，即实现了数据
和视图的双向响应式变化。如果在vm实例创建后，对dataSource添加新属性是无法实现响应式变化的。

注: Object.freeze(dataSource)会阻止修改对象属性值。

实例属性和方法都有前缀$, 如vm.$el, vm.$data等。

实例提供了多个生命周期钩子，如created, mounted, updated, destroyed等，可以在选项中自定义
回调方法执行自定义操作。钩子的this关键字指向vue实例，避免使用箭头函数。

教程中给出了vue实例的整个生命周期流程，可以看到以下几点：
1. 如果没有指定el选项，可以使用vm.$mount(el)方法指定元素。
2. 选项中如果有指定template模板，使用该模板进行渲染，否则就使用el的html标签进行渲染。这一点
也区分开了自定义组件和普通的html标签。
3. vue使用vm.$el替换原生的el标签实现虚拟DOM, 在此基础上实现响应式渲染。 

### 模板语法
#### 插值
1. 文本
双大括号为mustache语法，{{ message }}, 数据选项属性message发生变化，该文本值也会变化。
可以使用`<p v-once>{{ message }}</p>`来实现一次性渲染.

注: 类似document.getElementById().innerText = XXX;

2. html标签
```txt
<div id='ap6'>
  <p><span v-html="sp"/></p>
</div>

var ap6 = new Vue({
  el: '#ap6',
  data: {
    sp: '<a style='color: red'>I am red</a>'
  }
})
```
对用户输入的内容使用html插值容易导致XSS攻击，应只对可信内容使用。

注: 类似`document.getElementById().innerHTML = "<x>...</x>";`

3. 属性 
同上面所说，标签属性的改变使用v-bind指令，如v-bind:disabled="disableFlag"等, 其中disableFlag
必须为boolean值。

4. 模板表达式
如{{ num + 1}}, {{ ok ? 'yes' : 'no' }}都会被当作js表达式解析，其中num作为v-model双向绑定时
是字符串类型，{{num+1}}得到的是字符串的拼接。
模板表达式的解析是在沙盒中，只能访问如Math,Date等白名单对象，无法访问用户自定义全局变量，
访问时会报错该属性未定义。

#### 指令
指令一般是作用于单个表达式，如v-on:click='reverse', v-if='seen'等。
1. 参数 
即指令名称冒号后的值，如v-bind:href='url', v-on:click='reverse'中href, click都是参数，
等号后是参数值。

2. 动态参数
如v-on:[event]='dosth', 其中event可以为一个js表达式，如实例中有一个数据属性为event,值为
focus, 那么它就等价为v-on:focus='dosth'.通过这种形式，该标签就可以在不同时间以聚焦或点击
的不同动作调用相同的方法。(这种需求还是比较少见, 其他指令的参数动态性可能有点用)
动态表达式中不能有空格和引号，大写字母会被强制转换为小写。

3. 修饰符
如v-on:submit.prevent='sub'中参数submit后的.prevent指出该指令以特殊方式绑定，即调用
event.preventDefault()语句。

#### 缩写
v-bind:href='url'可以缩写为:href='url',
v-on:click='dosth'可以缩写为@click='dosth'.

### 计算属性和侦听器
#### 计算属性
在模板表达式中写比较复杂的算式可读性不好，而且不方便复用。这时可以使用计算属性。如:
```txt
<p>{{ reverseTxt }}</p>

var ap7 = new Vue({
  el: '#ap7',
  data: {
    txt: 'sdg'  
  },
  computed: {
    reverseTxt: function() {
      return this.txt.split('').reverse().join('');  
    }
  }
});
```
计算属性与方法的不同在于计算属性自带缓存，当this.txt没有发生改变时，不会重新计算直接返回
缓存值。
计算属性与侦听器的不同在于计算属性可以同时监控多个属性的变化，而侦听器只能针对单个属性的变化
分别定义函数。
计算属性默认是get方法，即计算结果值由"监测"的属性计算得到，但也可以通过设置计算属性值反过来
设置监测的属性值。通过这种联动可以实现实例中属性的双向影响，感觉在某些场景中这种相互影响非常
实用。代码如:
```txt
computed: {
 reverseTxt: {
   get: function() {
      return this.txt.split('').reverse().join('');  
   },
   set: function(val) {
      this.txt = val.split('').reverse().join('');  
   }
 } 
}
```

侦听器在属性值发生变化时可以调用相应的函数，如发出ajax异步请求等。为防止请求过于频繁，教程中
使用lodash的debounce方法限制请求间隔，使用axios发出ajax请求。

### class与style绑定
v-bind指令在设置标签的样式如class, style属性时除了字符串，还可以绑定一个对象或数组。
1. class
传递对象:
如`<p v-bind:class="{real: isReal, active: isActive}"></p>`,这个绑定的对象
除了可以在这里直接定义，还可以定义在实例的data选项属性中，或是计算属性中(更强大的控制)。

其中，对象的属性名是具体的class名称，属性值是该class是否生效的boolean值。为truthy时该class
生效，为false时该class不生效。
注: **js中除false, 0, "", null, undefined, NaN以外，都是真值，即为truthy.**

实例中定义为`data: {isReal: true, isActive: false}`.

注: v-bind:class可以和普通的class属性共存。

传递数组:
比起使用boolean值控制class列表的对象语法，数组语法通过class列表的字符串数组进行控制，
如`v-bind:class="[aClass, bClass]"`，同理，为实现控制，这里的aClass,bClass是实例的属性名，
实例中有`data: {aClass: 'a', bClass: 'b'}`, a和b即为具体的class名称。当需要去除某个class时，
将对应属性值设置为''即可。如果需要动态控制，可以在数组语法中嵌套使用对象语法，
如`v-bind:class='[{aClass: aflag}, bClass]`.

用在组件上:
在自定义组件中通过以上2种方式带数据绑定的class会追加到组件的根元素中，不会覆盖已有的class列表。 

2. style
通过style绑定的是内联样式，直接指定样式，不需要中间的class层，适合样式少并分散的情况。

对象语法:
如`v-bind:style="{color: acolor, fontSize: fs + 'px'}"`, 实例中定义
`data: {acolor: 'red', fs: 30}`, 
同样的，可以将该对象定义在实例data中，或使用计算属性。
如`v-bind:style="sty"`, `data: {sty: {color: 'red', fontSize: '30px'}}`.

数组语法:
style的数组语法可以使用多个style对象进行控制，这里使用对象语法一个style对象即可以控制，
所以数组语法意义不大，就此略过。

自动添加前缀: 对于非标准的浏览器引擎CSS前缀，v-bind:style会自动添加前缀，可忽略。
多重值: style样式属性值除字符串外，还可以传递数组，vue会选择数组中最后一个支持的浏览器样式，
可忽略。

### 条件渲染
1. v-if
在单个标签中使用v-if="seen", 当seen为false时，刷新后该标签一闪而过后消失。应该是渲染的执行
顺序问题。当需要控制隐藏多个标签时，使用template标签并在其中使用v-if指令，发现没有出现闪烁
现象。

v-if后可以使用v-else-if，v-else指令块控制多个元素的显式隐藏。要求必须相应的元素必须紧靠在
一起，否则无法识别。

当使用v-if切换2个template元素组时，vue会复用已经有的元素，这样在切换时会出现元素中已有的
值(如用户的输入值)不会被清空的情况。这时可以给这2个template中相同的元素设置key属性，相当于
指定了id, 通过设置不同的key值，vue就不会复用该元素。而未指定key时，vue将复用相同元素提高
渲染速度。

2. v-show
v-show指令值为false时相当于style='display:none"，所以v-show元素始终存在于dom中。

注: v-if是真正的条件渲染，而且是惰性的(只有第一次为真时才开始渲染)，切换开销较大；而v-show
始终会渲染，初始开销大，但切换时只是CSS变换，切换开销小。
所以如果频繁切换应使用v-show, 切换较少时使用v-if.

注: 不应当在同一个元素内同时使用v-if和v-for指令，因为v-for指令优先级更高，这样当只需要渲染
其中一小部分元素时，却遍历了整个列表进行判断。这时应当使用计算属性过滤出需要的列表，对其
使用v-for指令渲染，这样更高效，而且将筛选逻辑解耦出来了(而且计算属性还自带缓存，可以复用)。

### 列表渲染
1. 渲染列表
v-for指令在li标签上使用可以渲染一个列表。
```txt
<li v-for="item in items">{{ item.txt }}</li>
data: {
  items: [
    {txt: "one"},
    {txt: "two"},
  ]
}
```
v-for还可以写为`v-for="(item, index) in items"`, index为自动添加的索引。
还可以使用of代替in, 如`v-for="(item, index) of items"`。

2. v-for中使用对象
如
```txt
<li v-for="value in obj">{{value}}</li>
data: {
  obj: {
    title: 'tt',
    name: 'ss'
  } 
}
```
同时显示对象属性名和值:
```txt
<li v-for="(value, name) in obj">{{name}}: {{value}}</li>
或
<li v-for="(value, name, index) in obj">{{index}}:{{name}}: {{value}}</li>
```
注: 模板表达式只能识别单个属性，{{name: value}}会报错。
遍历顺序为Object.keys()结果。

3. 维护状态
同前面v-if的元素复用类似，v-for指令在未指定key时使用默认的"就地更新"策略，即不会主动更改
dom元素位置，而是更新每个元素值。这种模式很高效，但它只适用于输出的DOM非常简单的情况。
一般建议是在使用v-for指令时，同时使用v-bind:key="item.id"值为每一个列表项指定id.
使用key后，会强制更新元素或组件而不是重复利用已有元素，适用于触发过渡效果。

4. 数组更新检测
当v-for的数组内容发生变化时，对应的列表也会发生变化，数组变化的方法有
push, pop, shift, unshift, splice, sort, reverse.这些方法会改变原数组，而其他另外一些方法
如filter, concat, slice等没有改变原数组，这时如果想要重新渲染列表，可以使用计算属性，
在其中将得到的新数组替换原属性即可(vue会尽量复用已有DOM, 不会马上销毁原有DOM重新渲染)。

注: 直接使用索引修改元素值如a[i] = 3和a.length = 3无法实现响应式更新。对于前者可以使用
Vue.set(vm.items, index, newValue)或vm.items.splice(index, 1, newValue),
对于后者可以使用vm.items.splice(newlength).

splice意思是拼接，splice(startIndex, deleteCount, item1, item2...)意为从startIndex(包括)开始删除
deleteCount个字符，并在相同位置插入元素item1, item2..., 该方法改变了原数组，方法的返回值是
被删除的元素数组。

5. 对象变更检测
前面说过，对于已经初始化完成的vue实例，后面再添加属性值是不支持响应式更新的。(即时支持
好像也没有实际作用)。但可以对属性对象进行修改。
如果添加单个属性可以使用`Vue.set(vm.obj, 'name', 29)`添加或修改属性，如果要添加多个时，
可以使用`vm.obj = Object.assign({}, vm.obj, {'name':29, 'sex': 'm'});`
这里新建一个vm.obj对象而不是直接`Object.assign(vm.obj, {...})`的原因经网上搜索，说如果直接
修改vm对象，可能会导致基于vm的元素出现渲染问题，所以还是使用新对象较好。而且使用{}当vm.obj
对象为undefined时不会报错。即assign的源对象可以为undefined. 

注: Object.assign()复制的是属性值，为浅拷贝，如果需要深拷贝，可以json序列化后再解析，即
let copy = JSON.parse(JSON.stringify(source));

6. 显示过滤/排序后的结果
前面已经说过，需要过滤时应使用计算属性或方法对数组处理后再使用v-for指令渲染(直接使用v-if
性能低，耦合度高)。在使用v-for循环嵌套时，列表不是data属性(是数据内部的次级列表)，无法直接
访问所以不能使用计算属性，只能使用方法来处理。

7. v-for使用值范围
`<p v-for="n in 10">{{n}}</p>`输出12345678910

8. template上使用v-for
对于一组需要多次重复的元素组，可以在template上使用v-for. 具体需求如表格。
```txt
<div id="b4">
      <table>
              <template v-for="row in rows">
                      <tr>
                              <td>{{row.a}}</td>
                              <td>{{row.b}}</td>
                      </tr>
              </template>
      </table>
</div>
var b4 = new Vue({
      el: '#b4',
      data: {
              rows: [
                      {a: '11', b: '12'},
                      {a: '21', b: '22'}
              ]
      }
});
```
9. 组件上使用v-for
前面说过，组件中应使用key区分每个列表内元素保证渲染正确。同时组件有自己的作用域，需要使用
prop来传递数据。
```txt
<ul>
  <li is="myComponent" 
  v-for="(item,index) in list" 
  :key = "item.id"
  :content = "item.text"
  @remove="list.splice(index, 1)"
  />
</ul>
```
其中is="myComponent"是因为html限制ul中只有li是有效标签，要在其中使用自定义元素myComponent
时，需要通过is进行标记。key为item.id, 组件props属性(数组)为`['content']`(即li标签显示内容),
赋值为item.text.最后是点击按钮触发remove事件时将数组中该项去除，这样会同步响应到视图中。

### 事件处理
1. 内联语句
如v-on:click="count += 1"可以让属性count自增1
2. 绑定到方法
使用如v-on:click="afterClicked"将动作绑定到实例方法，处理逻辑都在方法中定义。
3. 内联语句中调用方法
如v-on:click="say('oneClick')", 在内联语句中调用方法。此时可以用$event向方法中传入原生
DOM事件，如v-on:click="say('oneClick', $event)".
4. 事件修饰符
某些情况需要阻止事件的默认行为，如form表单提交的默认重载页面行为，一般是使用
event.preventDefault(), vue提供了修饰符简化该操作，如
```txt
.stop 阻止事件继续传播 
.prevent 阻止事件默认行为
.capture 捕获内部元素事件，捕获处理完毕后再交还子元素
.self 只处理自身的事件，内部元素触发的事件不进入该处理
.once 该事件方法只会被调用一次
.passive 告诉浏览器执行事件的默认行为(正好与.prevent相反), 
         与.prevent一起使用时.prevent会被忽略
```
5. 按键修饰符
监听键盘事件时，可以指定按键。
如v-on:keyup.enter="submit"回车键调用submit方法，
v-on:keyup.page-down="onPageDown"按下pageDown键时调用onPageDown方法。
键名可以使用KeyboardEvent.key得到。
可以通过以下方式获取:
```txt
 <div id="b5">
      <input @keyup="go($event)"/>
</div>

var b5 = new Vue({
      el: '#b5',
      methods: {
              go: function (e) {
                      console.log(e.key);
              }
      }
});
```
注：按键码keycode用法已经被废弃，应避免使用

6. 系统修饰键
键盘修饰键只有在按下时才能触发，有
```txt
.ctrl
.alt
.shift
.meta
```
如alt+c触发clear方法: <input @keyup.alt.c="clear">，
完整代码如下:
```txt
<div id="b5">
    <input @keyup.alt.c="clear" v-model="mess"/>
</div>
var b5 = new Vue({
      el: '#b5',
      data: {
              mess: ''
      },
      methods: {
              clear: function () {
                      this.mess = '';
              }
      }
});
```
上面的`@keyup.alt.c="clear"`当alt和其他的修饰键如ctrl, shift等一起按下时也会调用，使用
.exact修饰符可以控制只有alt被按下时才会调用clear方法,代码为`@keyup.alt.exact.c="clear"`.

7. 鼠标按钮修饰符
.left .right .middle

### 表单输入绑定

#### 基础用法
v-model实际是语法糖，它监听用户的输入事件并更新数据。
v-model适用于input, textarea, checkbox, radio, select元素。

text, textarea, select根据value属性的变化触发input事件。
checkbox, radio根据checked属性的变化触发change事件。

v-model绑定的值为元素值。如`<input type='checkbox' value='one' v-model='arr'>`中，复选框
选中时arr数组中有值one, 未勾选时无值one. 代码如下:
```txt
<div id="b6">
      <input type="checkbox" value="one" v-model="arr"/><label>one</label>
      <input type="checkbox" value="two" v-model="arr"/><label>two</label>
      <p>{{arr}}</p>
</div>

var b6 = new Vue({
      el: '#b6',
      data: {
              arr: []
      }
});
```
使用`<textarea>{{mess}}</textarea>`无法实现双向绑定，只有初始时可以成功渲染mess值，用户
在输入文本后，mess值并不会相应的变化，若要实现双向绑定必须使用`<textarea v-model='mess'/>`.

select下拉框:
```txt
<div id="b7">
      <select v-model="sel">
              <option disabled value="">please select</option>
              <option>A</option>
              <option>B</option>
              <option>C</option>
      </select>
      <p>{{sel}}</p>
</div>

var b7 = new Vue({
      el: '#b7',
      data: {
              sel: ''
      }
});
```
多选下拉框除绑定到一个数组外，标签使用multiple标记为可多选，具体选择时按住ctrl键可多选
`<select v-model='selected' multiple>...</select>`

#### 值绑定
以上使用v-model时单选框，复选框，下拉框的值都是静态的，为字符串(复选框可以为boolean值)。
实际使用时如下拉框，选中的选项需要绑定到一个对象，这时简单的绑定方式`<option>A</option>`
(该选项值为A)就不能满足需求，这时可以进一步对选项的值进行绑定，即值绑定。

即`<option v-bind:value="{name: 'zs', age: 20}"`.这样通过v-bind指令对value属性进一步绑定
即可满足要求。

如下代码展示了下拉框联动后获取子下拉框选择的具体对象信息:
```txt
<div id="b8">
      <select v-model="parent" @change="changeList">
              <option disabled value="">please select one</option>
              <option>a</option>
              <option>b</option>
      </select>
      <select v-model="child">
              <option disabled value="">please select one</option>
              <option v-for="item in list" :key="item.id" :value="item">{{ item.name }}</option>
      </select>
      <p>id: {{child.id}}</p>
      <p>name: {{child.name}}</p>
      <p>age: {{child.age}}</p>
</div>

var b8 = new Vue({
      el: '#b8',
      data: {
              parent: '',
              child: {},
              list: []
      },
      methods: {
            changeList: function () {
                  if (this.parent == 'a') {
                          this.list = [
                                  {id: 1, name: 'a1', age: 11},
                                  {id: 2, name: 'a2', age: 22}];
                  }else{
                          this.list = [
                                  {id: 3, name: 'b1', age: 33},
                                  {id: 4, name: 'b2', age: 44}];
                  }
            }
      }
});
```
可以注意到，要获取子下拉框选择的对象信息，直接绑定`:value="item"`.

#### 修饰符
.lazy
`<input v-model.lazy="mess" /><p>{{mess}}</p>`, 这时输入字符时显示文本不会马上改变，而是
回车或tab键后改变，即.lazy使用change事件，而不是input事件。

.number
`<input v-model.number='age' type='number'/>`将用户输入值变为数字类型。经测试，type='number'
有上下调整按钮，并且无法输入数字。不使用.number时typeof(b9.num)返回string类型。

.trim
`<input v-model.trim='txt'/>`去除首尾空白字符。

### 组件基础
#### 组件data必须是一个函数
自定义组件代码如下:
```txt
<div id="c1">
      <clock></clock>
</div>

Vue.component('clock', {
      data: function () {
              return { count: 0 };
      },
      template: '<button @click="count++">{{count}}</button>'
});
var c1 = new Vue({
      el: '#c1'
});
```
组件是可以复用的vue实例，如
```txt
  <div>
    <clock />
    <clock />
    <clock />
  </div>
```
其中每个clock都是一个不同的实例，都有自己的属性定义。所以组件定义中data属性不能同上面一样
是一个简单的对象，而需要是一个函数，该函数返回需要的data对象，这样每个实例就有自己的对象了。

`c1=new Vue({el: '#c1})`中c1是根实例，el是根实例特有的属性。

经测试发现，组件复用时这种写法`<clock/><clock/>`只有一个组件会显示，而
```txt
<clock></clock>
<clock></clock>
```
这种写法才能正确的显示多个自定义组件，原因不明。

#### 组件的组织 
组件是通过嵌套树的形式进行组织的。`Vue.component('(xxx', {...})`的形式是全局注册。
在全局注册后任意新创建的Vue根实例和子组件实例(即为全局)都可以使用该组件，
经测试将上面的组件定义和根实例定义顺序颠倒，vue报错`unknown custom element`.

#### 通过prop向子组件传递数据 
为了给组件传递值，Vue使用props属性将需要传递的属性名集合为一个数组，如下
```txt
Vue.component('xx', {
  props: ['title'],
  template: '<p>{{title}}</p>'
});
```
在组件模板中可以像访问data中的值一样访问props中的属性。
传值时只需要像普通html标签的属性值赋值一样即可，如`<clock title='wttClock'/>`.
同理，当属性值是动态值(如v-for列表中)时，一样使用如`v-bind:title='item.title'`进行属性绑定。

组件属性prop除了可以是字符串类型的属性外，还支持将一个对象作为属性。这样向组件传值时就
不需要逐个具体指明对象的属性值，只需要绑定该对象即可。
需要注意的是，传值时不能同字符串一样直接赋值，需要使用v-bind标签绑定值对象。即前面的缩写
冒号不可少。代码如下:
```txt
<div id="c1">
      <clock></clock>
</div>
Vue.component('clock', {
      data: function () {
              return { count: 0 };
      },
      template: '<button @click="count++">{{count}}</button>'
});
var c1 = new Vue({
      el: '#c1'
});

<div id="c1">
      <clock :property="{name: 'wttClock', color: 'red'}"></clock>
      <clock :property="{name: 'wttClock2', color: 'red2'}"></clock>
      <clock :property="{name: 'wttClock3', color: 'red3'}" other="GGG"></clock>
</div>
Vue.component('clock', {
      data: function () {
              return { count: 0};
      },
      props: ['property', 'other'],
      template: '<div>' +
              '<p>{{property.name}} is {{property.color}}</p>' +
              '<button @click="count++"> and {{other}},' +
              ' clicked {{count}} times</button></div>'
});

var c1 = new Vue({
      el: '#c1'
});
```
同时，需要注意的是，组件模板中使用了property属性对象的相关信息进行显示，使用组件时必须给出
property属性值，否则会报错。如这里会报错`cannot read property: name of undefined`, 对应着
模板第一处的`{{property.name}}`。

#### 单个根元素 
组件模板template中只能包含一个根元素，所以当模板中存在多个平级标签时，必须使用一个元素标签
将多个元素"包裹"起来。

#### 监听子组件事件
有时候需要根据组件内部子元素的事件修改自定义组件所在元素(即其父组件)的状态，如点击按钮修改
父组件中所有文本的字体大小, 这时就需要将自定义组件内部的事件"传播"给其父组件进行处理, 
反过来也可以说父组件监听子组件的事件.

实现该功能需要两步设置.
1. 在子组件上"发射"事件.如`<button @click="$emit('afterClicked')"></button>`, 其中将点击
操作通过内建的$emit方法触发一个事件, 指定事件名为afterClicked.
2. 在父组件中使用如`<self-component v-on:afterClicked="doSth"></self-component>`, 
这里需要注意的是这里的响应函数属于父组件,处理的属性也是父组件的属性,不可与子组件混淆.

具体代码如下:
```txt
<div id="c2" :style="{fontSize: fs}">
      <p>I am Text being affected by wtt click event</p>
  <wtt v-on:ee="cfs"></wtt>
</div>

Vue.component('wtt', {
   data: function () {
         return {
                 acolor: 'red'
         };
   },
   methods: {
           changeColor: function () {
                   this.acolor = 'black';
           }
   },
   template: '<div :style="{color: acolor}">' +
           '<p>WTT GO FUN</p>' +
           '<button @click="changeColor" :style="{color: acolor}">call wtt component inner methods to change color of' +
           ' wtt</button><br><br>'+
           '<button @click="$emit(\'ee\', 20)" :style="{color: acolor}">change parent text fontSize</button>'+
           '</div>'
});
var c2 = new Vue({
      el: '#c2',
      data: {
            fs: 10
      },
      methods: {
              cfs: function (am) {
                    this.fs = am;
              }
      }
});
```
其中,可以看到$emit方法还可以传递第二个参数, 这里代表新的字体大小, 即子组件触发事件时可以给出
更具体的信息或指令. 父组件进行响应处理时如果是表达式, 用$event可以得到该参数值,如果是方法,
直接如上使用第一个参数即可.

#### 组件上使用v-model
普通标签的v-model实际上是语法糖, 即`<input v-model='it' />`它等价于
`<input :value='it' :input='it = $event.target.value' />`, 即input标签的值取属性it的值, 
同时将input标签的输入值赋值给属性it, 这样就实现了双向绑定.

自定义组件实现双向绑定,同理如下
```txt
<wtt :value='it' :input='it = $event'></wtt>
```
其中, 首先wtt组件需要有value这个属性, 即props中有属性value; 再是wtt组件中的input标签同前面
所说需要触发一个事件名为'input'. 代码如下:
```txt
<div id="c3">
      <wtt-input :value="mess" @input="mess=$event"></wtt-input>
</div>
Vue.component('wtt-input', {
    props: ['value'],
    template: '<div>\
                <p>wtt-input value is {{value}}</p>\
                <input @input="$emit(\'input\', $event.target.value)" :value="value">\
               </div>'
});
var c3 = new Vue({
    el: '#c3',
    data: {
          mess: 'xxx'
    }
})
```
其中为了让组件内的值与prop mess同步显示, 使用了`:value="value"`进行绑定.
这时就可以在input框中输入值,通过p标签查看prop值; 同时在console中使用`c3.mess = 'gogo'`命令
后可以看到input框的值同步发生了改变, 从而验证出确实实现了双向绑定.

#### 通过插槽分发内容 
以上的自定义组件使用时是这种模板`<wtt></wtt>`, 如果想要像普通元素一样在标签中传值,如
`<p>message</p>`, 可以使用Vue的自定义元素slot, 使用时`<wtt>Hello World</wtt>`或直接内嵌
其他标签`<wtt><div><p>GO FUN</p><button>click me</button></div></wtt>`.然后只需要在组件
定义模板中插入`<slot></slot>`即可.具体代码略.

#### 动态组件 
某些场景下需要一个动态的组件, 即根据不同的条件该组件的类型可以切换.
代码如下:
```txt
<div id="c5">
      <button @click="cc">change the component type</button>
      <component :is="curComp"></component>
</div>

Vue.component('wtt-a', {
      template: '<div><p>I am A</p></div>'
});
Vue.component('wtt-b', {
      template: '<div><p>I am B</p></div>'
});
Vue.component('wtt-c', {
      template: '<div><p>I am C</p></div>'
});
var c5 = new Vue({
      el: '#c5',
      data: {
            comps: ['a', 'b', 'c'],
              index: 0
      },
      computed: {
            curComp: function () {
                  return 'wtt-' + this.comps[this.index];
            }
      },
      methods: {
              cc: function () {
                      this.index = ++this.index % this.comps.length;
              }
      }
})
```
编写过程中发现几点要注意:
1. 组件名要多个单词, 自定义高一点, 使用如a作为组件名时(a是超链接...), vue会给出警告.
2. 计算属性中不要忘记使用this引用data中的属性.

从代码中可以看出, 组件动态化主要就是利用了Vue的Component标签配合其is属性, 在is属性中指定
具体的组件名称即可实现组件类型的切换.

注: 除了可以使用具体的完整组件名称, 还可以使用一个对象数组, 对象属性包括组件名称和组件模板,
具体代码略过.

#### 解析DOM模板需要注意内容
如前面说过的, 某些标签如`<ul>`中只允许出现`<li>`标签,这时如果在其中加入自定义组件会被视为
无效标签而被提取到`<ul>`标签外,渲染出现问题.
如以下代码:
```txt
<div id="c6">
      <p>Hello world</p>
      <table>
              <wtt-row></wtt-row>
              <tr><td>Done</td></tr>
      </table>
</div>
Vue.component('wtt-row', {
      template: '<tr><td>I am wtt-row</td></tr>'
});
var c6 = new Vue({
      el: '#c6'
})
```

通过devTool查看元素可以看到,wtt-row被提取到table标签外, 渲染错误.这时可以使用
`<tr is='wtt-row'></tr>`代替`<wtt-row></wtt-row>`.再次查看, 可见渲染成功.
这是在普通的html页面中使用出现的问题,如果是在以下场景中使用就没有该问题, 
不需要使用is特性:

1. 字符串中, 如以上例子这样写也可以成功渲染.
```txt
<div id="c6">
      <p>Hello world</p>
      <wtt-table></wtt-table>
</div>
Vue.component('wtt-row', {
      template: '<tr><td>I am wtt-li</td></tr>'
});
Vue.component('wtt-table', {
      template: " <table> <wtt-row></wtt-row> <tr><td>Done</td></tr> </table>"
})

var c6 = new Vue({
      el: '#c6'
})
```

2. 单文件组件.vue, 暂略
3. `<script type="text/x-template">`, 暂略

### 深入了解组件

### 组件注册
#### 组件名
组件名推荐使用多个小写单词, 并且必须包含一个连字符, 这样可以避免与已有或未来的html标签名
冲突.

#### 全局注册
前面使用Vue.component('xx', {...})的方式即为全局注册, 在注册以后后面创建的vue根实例都可以
使用该组件, 其他组件也能使用.

#### 局部注册
全局注册的问题在于即使没有使用该组件,该组件注册后仍然会在最终的依赖结果中.这时可以使用局部
注册.代码如下:
```txt
<div id="c6">
      <p>Hello world</p>
      <table>
              <tr is="wtt-row"></tr>
      </table>
</div>

var wttRow={name: 'wtt-row',
      template: '<tr><td>I am wtt-row</td></tr>'};

var c6 = new Vue({
      el: '#c6',
      components: {
              'wtt-row': wttRow
      }
})
```
可以看出, 局部注册就是在需要使用自定义组件的vue实例中使用components属性列出所有需要的组件,
列出组件名称和对应的组件对象, 组件对象有name属性和template属性(与全局注册组件一致).

经测试wttRow也不能放在c6 vue实例后面定义, 否则报错`unknown custom element`, 对于这个问题
组件对象本身的定义位置无影响, 应该是vue渲染的顺序性(或者生命周期?)要求导致.

注: 局部注册的组件在子组件中不可用. 
这应该是显而易见的, 子组件中也可用的组件是全局注册的组件.

#### 模块系统
暂略

### Prop
#### prop的大小写
组件属性在定义时使用正常变量命名规范驼峰式命名方式(camelCase)如`wttTxt`, 但在html Dom中使用时如果
直接使用这种命名如`<wtt-com wttTxt='mes'></wtt-com>`, 浏览器无法正常显示, 在devTool中vue
显示了一个tip, 告知这种情况下, 应使用kebab-case方式, 即`<wtt-com wtt-txt='mes'></wtt-com>`.

#### prop类型
属性除了有字符串类型, 还有其他类型, 如布尔型`checked=true`, 数字型`width=100`等,这时props
字符串数组无法满足需求, 可以使用对象来定义props. 如
```txt
props: {
  message: String,
  checked: Boolean,
  width: Number
}
```
其中, 对象属性名为prop名称, 对应属性值为prop类型. 其他类型有Array, Object, Function, 
Promise.

#### 传递静态或动态prop 
如前面所说, 在传递prop属性值时, 直接赋值如`<wtt-com num='88'></wtt-com>`,这时属性
num的值是字符串"88", 如果需要传递数字类型, 需要使用v-bind指令,如
`<wtt-com :num='88'></wtt-com>`. 这时`props: {num: Number}`即可正常工作.
其他类型, Boolean, Array, Object类型同理都需要使用v-bind指令.

注: 不带参数的v-bind指令如`<wtt-com v-bind='obj'></wtt-com>`是将obj的所有属性作为prop传入,
代码略.

#### 单向数据流
有时候组件需要"修改"通过prop属性传递进来的值, 主要就是将传进来的该属性值作为初始值,
后续在组件内部进行修改.如下代码:
```txt
<div id="c7">
      <wtt-com :init-num="88"></wtt-com>
</div>
var wttCom = {name: 'wtt-com',
      props: {
            initNum: Number
      },
      data: function(){
          return {
                  wttCount: this.initNum
          }
      },
      methods: {
          add: function () {
                this.wttCount++;
          }
      },
      template: '<div><p>{{wttCount}}</p><button @click="initNum++">increment' +
              ' wttTxt</button></div>'};

var c7 = new Vue({
      el: '#c7',
      components: {
              'wtt-com': wttCom
      }
})
```
运行代码, vue给出报错信息:`应避免直接修改一个prop属性, 应使用data或计算属性`, 这里我们改成
`wttCount++`即可实现功能.

另外, 经测试, 如果这样写`@click='this.initNum++'`, 点击按钮无反应, 可以想到template中的
this已经没有指向该组件实例了(可能是渲染时的其他中间对象). 但如果绑定到方法上`@click='add'`,
这时就需要如上面代码所写`this.wttCount++`, 因为这时this确实是指向该组件实例的, 不加this
则会报错.

这种只能从父组件传递数据到子组件, 而子组件不能直接修改prop的方式即为单向数据流.

不过, 因为javascript中对象和数组是引用传递, 所以对于数组或对象类型的prop属性, 如果在组件中
直接修改prop, vue不会报错并且修改成功. 对于该问题, 为避免影响到父组件, 可以在data中拷贝对象
进行处理, 代码如下:
```txt
<div id="c7">
      <wtt-com :init-num="{val: 88}"></wtt-com>
</div>
var wttCom = {name: 'wtt-com',
      props: {
            initNum: Object
      },
      data: function(){
          return {
                  wttCount: Object.assign({}, initNum)
          }
      },
      template: '<div><p>initNum is {{initNum}}</p><p>wttCount is {{wttCount}}</p>' +
              '<button @click="wttCount.val++">increment wttCount</button></div>'};

var c7 = new Vue({
      el: '#c7',
      components: {
              'wtt-com': wttCom
      }
})
```
注: 使用时同样需注意Object.assign的浅拷贝问题.

#### prop验证 
prop除了可以指定类型外, 还可以指定是否必输, 默认值, 自定义验证函数等. 如
```txt
props: {
  wttProp: {
    type: Number,
    required: true,
    default: 100,    // 对象或数组的默认值是从函数获得
    validator: funtion(val){  // 值必须是66, 77, 88之一
      return [66, 77, 88].indexOf(val) != -1;  
    }
  } 
}
```
prop验证是在组件实例创建前完成, 所以default, validator函数不能使用data, computed等中的值.

注: 除基本类型外, prop还可以为自定义对象类型, 如`props: {man: Person}`, validator中可以用
instanceof验证类型.

#### 非prop的特性
某些场景下, 子组件没有定义某个prop, 这时可以直接传递需要的prop值, 如给某些组件打上是否
激活的标记, 如`<wtt-com :disabled="true"></wtt-com>`, wtt-com中可以不用定义disabled特性,
该特性会被添加到组件根元素下,外界需要判断时直接判断即可.

外部传入的prop属性通常会替换组件模板内已定义的值, 而class和style特性会将两者合并起来.


### 自定义事件
### 插槽
### 动态组件&异步组件
### 处理边界情况


### 过渡&动画

### 进入/离开&列表过渡
### 状态过渡


### 可复用性&组合

### 混入
### 自定义指令
### 渲染函数&JSX
### 插件
### 过滤器


### 工具

### 单文件组件 
### 单元测试
### TypeScript支持
### 生产环境部署


### 规模化

### 路由 
### 状态管理
### 服务端渲染


### 内在

### 深入响应式原理

## springboot整合vue
1. 建立父项目, 有2个模块. 在父项目中定义spring-boot-starter-parent版本
2. 用springboot initializer新建子模块backend, 依赖选starter-web和mybatis, 建立后修改parent
改为第一步中新建的父项目, 修改build 插件实现拷贝vue相关静态文件到backend的static目录下.  
3. 使用windows安装包安装node, 安装过程中选择第二个带npm的选项.
4. `npm install -g @vue/cli`, 完成后使用`vue --version`查看版本.
5. 在frontend目录下执行`vue create frontend`, 删除frontend下的src目录, 将生成的vue项目
frontend下的所有内容提到上一级的frontend目录中.
6. 编写后台代码, 启动测试后台服务
7. 添加axios. frontend目录下执行`npm install axios --save`.
8. 使用vue-cli-plugin-element添加element-ui组件.frontend目录下执行命令为`vue add element`
9. idea添加vue.js插件(网络不好未安装); 
   filetypes - html - .vue; 
   javascript es6;
   editor - file and code templates -> + Vue File, extension vue, open with html format
10. 修改element.js, 引入table, tableColumn组件, 修改App.vue, 使用axios请求后台.
后台服务地址暂定为请求根目录`/xxx`.
11. 在backend中执行`mvn process-resources`将frontend dist全部内容拷贝到backend 
`src/main/resources`中.
12. 启动BackendApplication main方法.
13. frontend下添加.eslintrc.js, 添加devServe配置, 使得npm run serve时可以访问后端服务.  

别人的架子
1. 安装node, npm
2. 执行命令`npm config set sass_binary_site=https://npm.taobao.org/mirrors/node-sass`  
3. frontend下npm install
4. npm run serve查看页面
5. npm run build生成
6. 主目录执行`mvn --projects backend springboot:run --settings d://alimaven//settings.xml`.

## webpack 4.41.2使用
### 概念
1. entry
处理依赖的起始位置 默认./src
2. output
打包输出(emit)信息,包括路径,文件名等
3. loader
loader可以将非js文件转换为依赖处理. 可以在module.rules中配置.
test选中处理目标(可以用正则表达式), use指明使用哪个loader.
4. plugins
实现如打包优化和压缩等一系列功能.
5. 模式
开发或生产模式, 启用webpack内置优化

### 指南
1. npm init -y
   npm i webpack webpack-cli --save-dev
2. 新建dist/index.html, src/index.js, 修改package.json为private
3. npm i --save lodash
4. npx webpack  该命令是运行`node_modules`中的webpack命令, 将src/index.js转变为dist/main.js
5.  使用浏览器打开index.html查看效果
6. 新建webpack.config.js, 其中output修改为dist/bundle.js, 所以dist/html中也需要修改.
7. npm webpack --config webpack.config.js  这里--config可省略,默认即为webpack.config.js
8. 添加npm脚本, npm run build代替npx命令

管理资源
1. npm i --save-dev style-loader css-loader  
2. 修改webpack.config.js指定使用style-loader, css-loader加载css文件. 
3. 新建src/style.css, 修改index.js import './style.css'; element.classList.add('hello');
4. npm run build
5. 浏览器打开index.html查看效果, 通过dev-tool查看网页代码head标签, 源码被压缩无法查看

图片
1. npm i file-loader --save-dev
2. 修改webpack.config.js使用fileloader处理png, jpg等格式文件
3. 在src下添加图片, src/index.js引入图片, src/style.css使用该图片作为背景图片
4. npm run build
5. 浏览器打开index.html查看效果, 通过dev-tool查看网页代码head标签, 源码被压缩无法查看

字体
file-loader同样可以处理字体, 具体过程同上, src/style.css中可以使用@font-face引入

加载本地数据
使用csv-loader, xml-loader可以加载本地的csv/tsv, xml数据文件
还可以处理json格式数据, src/index.js中引入的变量为解析后的JSON数据(经测试xml实际被转换为
一个对象, 根节点为属性名).

<hr />
<img src="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/20191119_1.jpg" class="full-image" />
