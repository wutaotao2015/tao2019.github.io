---
title: VueNote
categories: Vue
tags:
  - Vue
updated: 2019-11-21 18:02:57
date: 2019-11-19 17:23:01
abbrlink:
---
note on learning Vue
<!-- more -->
## 官网教程

### 安装
直接下载vue.js并在html中引用即可。这里使用的vue版本为2.6.10.

### 声明式渲染，条件与循环等
数据可以绑定到DOM文本:如文本插值{{ message }}, 
DOM属性: 如直接在html标签中使用指令v-bind:title="eleTitle"改变鼠标悬停效果,
DOM结构: 如使用指令v-if="seen"控制是否显示标签(控制结构时还可以提供fade in, out等其他动画效果)

v-for="item in itemList"在li标签中的应用。
v-on:click="afterClick"绑定点击事件为afterClick方法。
v-model="message"为双向数据绑定。

可以通过如下方式自定义组件:
```txt
Vue.component('todo', {
  props: ['prop1', 'prop2'],
  template: '<li>{{ prop1.text }}</li>'
});

var ele = new Vue({
 el: '#ap5',
 data: {
   list: [
    {id: 0, text: 'one'},
    {id: 1, text: 'two'},
    {id: 2, text: 'three'}
   ]  
 }
});
```
自定义组件，使用时如
```txt
<div id='ap5'>
  <todo v-for="item in list" v-bind:prop1="item" v-bind:key="item.id"/>
</div>
```
可以看到，自定义组件todo使用组件属性prop使得组件动态显示外界传递的数据内容。这与上面的
v-bind:title="message"是一样的。

### Vue实例
在vue中，一个组件实际上是一个预定义的Vue实例。每个Vue实例可以接受多个选项。
1. 数据选项 data
当实例创建时，data选项中已经存在的属性会被加入到vue的响应式系统中，如
```txt
var dataSource = {text: 1};
var vm = new Vue({
  data: dataSource 
});
```
这时无论改变vm.text还是改变dataSource.text的值，另一个的值都会同步发生改变，即实现了数据
和视图的双向响应式变化。如果在vm实例创建后，对dataSource添加新属性是无法实现响应式变化的。

注: Object.freeze(dataSource)会阻止修改对象属性值。

实例属性和方法都有前缀$, 如vm.$el, vm.$data等。

实例提供了多个生命周期钩子，如created, mounted, updated, destroyed等，可以在选项中自定义
回调方法执行自定义操作。钩子的this关键字指向vue实例，避免使用箭头函数。

教程中给出了vue实例的整个生命周期流程，可以看到以下几点：
1. 如果没有指定el选项，可以使用vm.$mount(el)方法指定元素。
2. 选项中如果有指定template模板，使用该模板进行渲染，否则就使用el的html标签进行渲染。这一点
也区分开了自定义组件和普通的html标签。
3. vue使用vm.$el替换原生的el标签实现虚拟DOM, 在此基础上实现响应式渲染。 

### 模板语法
#### 插值
1. 文本
双大括号为mustache语法，{{ message }}, 数据选项属性message发生变化，该文本值也会变化。
可以使用`<p v-once>{{ message }}</p>`来实现一次性渲染.

注: 类似document.getElementById().innerText = XXX;

2. html标签
```txt
<div id='ap6'>
  <p><span v-html="sp"/></p>
</div>

var ap6 = new Vue({
  el: '#ap6',
  data: {
    sp: '<a style='color: red'>I am red</a>'
  }
})
```
对用户输入的内容使用html插值容易导致XSS攻击，应只对可信内容使用。

注: 类似`document.getElementById().innerHTML = "<x>...</x>";`

3. 属性 
同上面所说，标签属性的改变使用v-bind指令，如v-bind:disabled="disableFlag"等, 其中disableFlag
必须为boolean值。

4. 模板表达式
如{{ num + 1}}, {{ ok ? 'yes' : 'no' }}都会被当作js表达式解析，其中num作为v-model双向绑定时
是字符串类型，{{num+1}}得到的是字符串的拼接。
模板表达式的解析是在沙盒中，只能访问如Math,Date等白名单对象，无法访问用户自定义全局变量，
访问时会报错该属性未定义。

#### 指令
指令一般是作用于单个表达式，如v-on:click='reverse', v-if='seen'等。
1. 参数 
即指令名称冒号后的值，如v-bind:href='url', v-on:click='reverse'中href, click都是参数，
等号后是参数值。

2. 动态参数
如v-on:[event]='dosth', 其中event可以为一个js表达式，如实例中有一个数据属性为event,值为
focus, 那么它就等价为v-on:focus='dosth'.通过这种形式，该标签就可以在不同时间以聚焦或点击
的不同动作调用相同的方法。(这种需求还是比较少见, 其他指令的参数动态性可能有点用)
动态表达式中不能有空格和引号，大写字母会被强制转换为小写。

3. 修饰符
如v-on:submit.prevent='sub'中参数submit后的.prevent指出该指令以特殊方式绑定，即调用
event.preventDefault()语句。

#### 缩写
v-bind:href='url'可以缩写为:href='url',
v-on:click='dosth'可以缩写为@click='dosth'.

### 计算属性和侦听器
#### 计算属性
在模板表达式中写比较复杂的算式可读性不好，而且不方便复用。这时可以使用计算属性。如:
```txt
<p>{{ reverseTxt }}</p>

var ap7 = new Vue({
  el: '#ap7',
  data: {
    txt: 'sdg'  
  },
  computed: {
    reverseTxt: function() {
      return this.txt.split('').reverse().join('');  
    }
  }
});
```
计算属性与方法的不同在于计算属性自带缓存，当this.txt没有发生改变时，不会重新计算直接返回
缓存值。
计算属性与侦听器的不同在于计算属性可以同时监控多个属性的变化，而侦听器只能针对单个属性的变化
分别定义函数。
计算属性默认是get方法，即计算结果值由"监测"的属性计算得到，但也可以通过设置计算属性值反过来
设置监测的属性值。通过这种联动可以实现实例中属性的双向影响，感觉在某些场景中这种相互影响非常
实用。代码如:
```txt
computed: {
 reverseTxt: {
   get: function() {
      return this.txt.split('').reverse().join('');  
   },
   set: function(val) {
      this.txt = val.split('').reverse().join('');  
   }
 } 
}
```

侦听器在属性值发生变化时可以调用相应的函数，如发出ajax异步请求等。为防止请求过于频繁，教程中
使用lodash的debounce方法限制请求间隔，使用axios发出ajax请求。

### class与style绑定
v-bind指令在设置标签的样式如class, style属性时除了字符串，还可以绑定一个对象或数组。
1. class
传递对象:
如`<p v-bind:class="{real: isReal, active: isActive}"></p>`,这个绑定的对象
除了可以在这里直接定义，还可以定义在实例的data选项属性中，或是计算属性中(更强大的控制)。

其中，对象的属性名是具体的class名称，属性值是该class是否生效的boolean值。为truthy时该class
生效，为false时该class不生效。
注: **js中除false, 0, "", null, undefined, NaN以外，都是真值，即为truthy.**

实例中定义为`data: {isReal: true, isActive: false}`.

注: v-bind:class可以和普通的class属性共存。

传递数组:
比起使用boolean值控制class列表的对象语法，数组语法通过class列表的字符串数组进行控制，
如`v-bind:class="[aClass, bClass]"`，同理，为实现控制，这里的aClass,bClass是实例的属性名，
实例中有`data: {aClass: 'a', bClass: 'b'}`, a和b即为具体的class名称。当需要去除某个class时，
将对应属性值设置为''即可。如果需要动态控制，可以在数组语法中嵌套使用对象语法，
如`v-bind:class='[{aClass: aflag}, bClass]`.

用在组件上:
在自定义组件中通过以上2种方式带数据绑定的class会追加到组件的根元素中，不会覆盖已有的class列表。 

2. style
通过style绑定的是内联样式，直接指定样式，不需要中间的class层，适合样式少并分散的情况。

对象语法:
如`v-bind:style="{color: acolor, fontSize: fs + 'px'}"`, 实例中定义
`data: {acolor: 'red', fs: 30}`, 
同样的，可以将该对象定义在实例data中，或使用计算属性。
如`v-bind:style="sty"`, `data: {sty: {color: 'red', fontSize: '30px'}}`.

数组语法:
style的数组语法可以使用多个style对象进行控制，这里使用对象语法一个style对象即可以控制，
所以数组语法意义不大，就此略过。

自动添加前缀: 对于非标准的浏览器引擎CSS前缀，v-bind:style会自动添加前缀，可忽略。
多重值: style样式属性值除字符串外，还可以传递数组，vue会选择数组中最后一个支持的浏览器样式，
可忽略。

### 条件渲染
1. v-if
在单个标签中使用v-if="seen", 当seen为false时，刷新后该标签一闪而过后消失。应该是渲染的执行
顺序问题。当需要控制隐藏多个标签时，使用template标签并在其中使用v-if指令，发现没有出现闪烁
现象。

v-if后可以使用v-else-if，v-else指令块控制多个元素的显式隐藏。要求必须相应的元素必须紧靠在
一起，否则无法识别。

当使用v-if切换2个template元素组时，vue会复用已经有的元素，这样在切换时会出现元素中已有的
值(如用户的输入值)不会被清空的情况。这时可以给这2个template中相同的元素设置key属性，相当于
指定了id, 通过设置不同的key值，vue就不会复用该元素。而未指定key时，vue将复用相同元素提高
渲染速度。

2. v-show
v-show指令值为false时相当于style='display:none"，所以v-show元素始终存在于dom中。

注: v-if是真正的条件渲染，而且是惰性的(只有第一次为真时才开始渲染)，切换开销较大；而v-show
始终会渲染，初始开销大，但切换时只是CSS变换，切换开销小。
所以如果频繁切换应使用v-show, 切换较少时使用v-if.

注: 不应当在同一个元素内同时使用v-if和v-for指令，因为v-for指令优先级更高，这样当只需要渲染
其中一小部分元素时，却遍历了整个列表进行判断。这时应当使用计算属性过滤出需要的列表，对其
使用v-for指令渲染，这样更高效，而且将筛选逻辑解耦出来了(而且计算属性还自带缓存，可以复用)。

### 列表渲染
1. 渲染列表
v-for指令在li标签上使用可以渲染一个列表。
```txt
<li v-for="item in items">{{ item.txt }}</li>
data: {
  items: [
    {txt: "one"},
    {txt: "two"},
  ]
}
```
v-for还可以写为`v-for="(item, index) in items"`, index为自动添加的索引。
还可以使用of代替in, 如`v-for="(item, index) of items"`。

2. v-for中使用对象
如
```txt
<li v-for="value in obj">{{value}}</li>
data: {
  obj: {
    title: 'tt',
    name: 'ss'
  } 
}
```
同时显示对象属性名和值:
```txt
<li v-for="(value, name) in obj">{{name}}: {{value}}</li>
或
<li v-for="(value, name, index) in obj">{{index}}:{{name}}: {{value}}</li>
```
注: 模板表达式只能识别单个属性，{{name: value}}会报错。
遍历顺序为Object.keys()结果。

3. 维护状态
同前面v-if的元素复用类似，v-for指令在未指定key时使用默认的"就地更新"策略，即不会主动更改
dom元素位置，而是更新每个元素值。这种模式很高效，但它只适用于输出的DOM非常简单的情况。
一般建议是在使用v-for指令时，同时使用v-bind:key="item.id"值为每一个列表项指定id.







### 事件处理
### 表单输入绑定
### 组件基础

### 组件注册
### Prop
### 自定义事件
### 插槽
### 动态组件&异步组件
### 处理边界情况

### 进入/离开&列表过渡
### 状态过渡

### 混入
### 自定义指令
### 渲染函数&JSX
### 插件
### 过滤器

### 单文件组件 
### 单元测试
### TypeScript支持
### 生产环境部署

### 路由 
### 状态管理
### 服务端渲染

### 深入响应式原理

##

##
<hr />
<img src="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/20191119_1.jpg" class="full-image" />
